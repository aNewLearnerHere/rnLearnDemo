import React from 'react';
import {
    View,
    Text,
    Image,
    StyleSheet,
    BackAndroid,
    NativeModules,
    Platform,
    NavigatorIOS,
} from 'react-native';
import PropTypes from 'prop-types';

import NavigationCardStack from './NavigationExperimental/NavigationCardStack';

import {
    NavigationHeader
} from './NavigationHeader';

import {
    assignItems
} from './navUtil';

import StaticComponent from './StaticComponent';
import Color from './Color';

const GESTURE_RESPONSE_DISTANCE = 30;

const Directions = {
    'HORIZONTAL': 'horizontal',
    'VERTICAL': 'vertical',
};

function NavigationViewBuilder (emitter, navState, options = {}) {

    class NavigationView extends React.Component {

        state = {
            navigationState: navState.getState(),
            direction: this.props.direction,
            enableGestures: this.props.enableGestures
        };

        componentWillMount () {
            emitter.on('navigation', ({ action, data }) => {
                if(action === 'push') {
                    this.setState(setStatePush);
                } else if(action === 'pop') {
                    this.setState(setStatePop);
                } else if(action === 'back') {
                    this.setState(setStateBack);
                } else if(action === 'forward') {
                    this.setState(setStateForward);
                } else if(action === 'jumpTo') {
                    this.setState(setStateJumpTo);
                }
            });
            // 可以在应用内创建多个栈，但是只能有一个栈监听这个事件
            if(typeof(options.backAndroidBind) === 'undefined' || options.backAndroidBind) {
                /**
                 * 绑定 Android 的返回键
                 */
                BackAndroid.addEventListener('hardwareBackPress', onBackAndroid);
            }

            if(global.forbidHarwareBack) {
                NativeModules.SCCRNControlBridge.SCCRNForbidGesture && NativeModules.SCCRNControlBridge.SCCRNForbidGesture();
            }

        }

        componentWillUpdate () {
            /**
             * ios 特供，当 RN 的导航栈在栈底的时候，放开客户端原生的右划返回，否则禁用客户端原生的右滑返回
             */
            try {
                if(navState.getIndex() > 0 || global.forbidHarwareBack) {
                    NativeModules.SCCRNControlBridge.SCCRNForbidGesture && NativeModules.SCCRNControlBridge.SCCRNForbidGesture();
                } else {
                    NativeModules.SCCRNControlBridge.SCCRNAllowGesture && NativeModules.SCCRNControlBridge.SCCRNAllowGesture();
                }
            } catch(e) {
            }
        }

        componentDidMount () {

        }

        componentWillUnmount () {
            BackAndroid.removeEventListener('hardwareBackPress', onBackAndroid);
            emitter.removeAllListeners();
        }

        renderHeader = (sceneProps) => {
            const {
              scene: {
                route: {
                  _emitter,
                  navigation: {
                    hidden, hiddenHeader, headerDisplayHidden,
                    headerStyle,
                    left, leftTextStyle, leftImgStyle, leftArrowStyle,
                    right, rightTextStyle, rightImgStyle,
                    title, titleTextStyle, titleImgStyle
                  }
                }
              }
            } = sceneProps;

            if(hidden === true || hiddenHeader === true) {
                return;
            }
            return (
              <NavigationHeader
                headerStyle={Object.assign({}, this.props.headerStyle, headerStyle)}
                left={assignItems(this.props.left, left)}
                leftTextStyle={Object.assign({}, this.props.leftTextStyle, leftTextStyle)}
                leftImgStyle={Object.assign({}, this.props.leftImgStyle, leftImgStyle)}
                leftArrowStyle={Object.assign({}, this.props.leftArrowStyle, leftArrowStyle)}
                right={assignItems(this.props.right, right)}
                rightTextStyle={Object.assign({}, this.props.rightTextStyle, rightTextStyle)}
                rightImgStyle={Object.assign({}, this.props.rightImgStyle, rightImgStyle)}
                title={assignItems(this.props.title, title)}
                titleTextStyle={Object.assign({}, this.props.titleTextStyle, titleTextStyle)}
                titleImgStyle={Object.assign({}, this.props.titleImgStyle, titleImgStyle)}
                sceneProps={sceneProps}
                emitter={_emitter}
                onNavigateBack={onNavigateBack}
                defaultLeftArrow={this.props.defaultLeftArrow}
                headerDisplayHidden={headerDisplayHidden}
              />
            );
        }

        renderScene = (sceneProps) => {
            dynamicDefineComponentProperty(sceneProps);
            const {
              scene: {
                route: {
                  navigation: {
                    headerStyle,
                  }
                }
              }
            } = sceneProps;
            const hStyle = Object.assign({}, this.props.headerStyle, headerStyle);
            return (
              <StaticComponent {...sceneProps} >
                  <View style={[styles.container,hStyle.backgroundColor?{backgroundColor:hStyle.backgroundColor}:{}]}>
                      {this.renderHeader(sceneProps)}
                      <View style={[styles.flex, { zIndex: 1,backgroundColor:Color.G3 }]}>
                          {sceneProps.scene.route.ComponentInstance}
                      </View>
                  </View>
              </StaticComponent>
            );
        }

        render () {
            return (

              <NavigationCardStack
                direction={this.state.direction}
                gestureResponseDistance={this.state.enableGestures ? GESTURE_RESPONSE_DISTANCE : -1}
                cardStyle={[styles.cardStyle, this.props.cardStyle]}
                navigationState={this.state.navigationState}
                renderScene={this.renderScene}
                onNavigateBack={onNavigateBack}
              />
            );
        }
    }

 /**
     * 返回 navigation 上对应属性的最终值（通过处理页面中静态 navigation 和 props 对应属性的值）
     * @param {获取对应导航栈属性方法} actionFn
     * @param {对应 props 属性的值} propsVal
     */
    function navigationActionVal(actionFn, propsVal) {
        return typeof actionFn() === 'boolean' ? actionFn() : propsVal;
    }

    /**
     * 动作为 push 的 action
     * @param {NavigationViewState} state
     * @param {NavigationViewProps} props
     */
    function setStatePush (state, props) {
        return {
            navigationState: navState.getState(),
            direction: navigationActionVal(getNavigationDirection, props.direction),
            enableGestures: navigationActionVal(getNavigationEnableGestures, props.enableGestures)
        };
    }


    /**
     * 动作为 pop 的 action
     * @param {NavigationViewState} state
     * @param {NavigationViewProps} props
     */
    function setStatePop (state, props) {
        return {
            navigationState: navState.getState(),
            direction: navigationActionVal(getNavigationDirection, props.direction),
            enableGestures: navigationActionVal(getNavigationEnableGestures, props.enableGestures)
        };
    }

    /**
     * 动作为 back 的 action
     * @param {NavigationViewState} state
     * @param {NavigationViewProps} props
     */
    function setStateBack (state, props) {
        return {
            navigationState: navState.getState(),
            direction: navigationActionVal(getNavigationDirection, props.direction),
            enableGestures: navigationActionVal(getNavigationEnableGestures, props.enableGestures)
        };
    }

    /**
     * 动作为 forward 的 action
     * @param {NavigationViewState} state
     * @param {NavigationViewProps} props
     */
    function setStateForward (state, props) {
        return {
            navigationState: navState.getState(),
            direction: navigationActionVal(getNavigationDirection, props.direction),
            enableGestures: navigationActionVal(getNavigationEnableGestures, props.enableGestures)
        };
    }


    /**
     * 动作为 jumpTo 的 action
     * @param {NavigationViewState} state
     * @param {NavigationViewProps} props
     */
    function setStateJumpTo (state, props) {
        return {
            navigationState: navState.getState(),
            direction: navigationActionVal(getNavigationDirection, props.direction),
            enableGestures: navigationActionVal(getNavigationEnableGestures, props.enableGestures)
        };
    }


    /**
     * 获取 index 对应导航栈的 direction
     * @param {Object} state  navState
     */
    function getNavigationDirection (state = navState.getState()) {
        const route = state.routes[state.index];
        if(route && route.navigation) {
            return route.navigation.direction;
        }
    }


    /**
     * 获取 index 对应导航栈的 enableGestures
     * @param {Object} state  navState
     */
    function getNavigationEnableGestures (state = navState.getState()) {
        const route = state.routes[state.index];
        if(route && route.navigation) {
            return route.navigation.enableGestures;
        }
    }


    /**
     * 处理 Android 实体键的返回事件
     */
    function onBackAndroid () {
        const index = navState.getIndex();
        const route = navState.getRoute(index);

        if(!route) {
            return;
        }

        if(route.navigation && typeof route.navigation.onBackAndroid === 'function') {
            route.navigation.onBackAndroid(navState.getState());
            return true;
        } else if(route.navigation && typeof route.navigation.handleAndroidBack === 'function') {
            route.navigation.handleAndroidBack(route.emitter, navState.getState());
            return true;
        } else if(index > 0) {
            onNavigateBack();
            return true;
        } else if(global.forbidHarwareBack) {
            return true;
        } else if(index === 0) {
            const SCCRNControlBridge = NativeModules.SCCRNControlBridge;
            if(SCCRNControlBridge && typeof SCCRNControlBridge.SCCRNCloseView === 'function') {
                onNavigateBack();
                return true;
            } else {
                return false;
            }
        }
        return false;
    }


    /**
     * 触发通用的导航返回事件
     */
    function onNavigateBack () {
        emitter.emit('navigateBack');
    }


    /**
     * 为当前的导航对象的原型链动态的添加一些属性，以满足业务需要
     * @param {Object} sceneProps 导航场景的属性集合
     */
    function dynamicDefineComponentProperty (sceneProps) {
        try {
            const Component = sceneProps.scene.route.ComponentInstance.type;
            const navigator = {
                emitter: sceneProps.scene.route.emitter,
                sceneProps: sceneProps,
                setNavigation: setNaviagtionEmitter(sceneProps.scene.route._emitter),
                hideNavigation: setNaviagtionHideEmitter(sceneProps.scene.route._emitter),
                showNavigation: setNaviagtionShowEmitter(sceneProps.scene.route._emitter)
            };
            Object.assign(Component.prototype, navigator);

            // 随着内置属性的增多，为了不与用户在组件内定义的属性冲突，考虑将内置的属性写入一个 navigator 对象内
            // 0.* 版本暂不做此设置
            // Object.assign(Component.prototype, {navigator});
        } catch(e) {
        }
    }


    /**
     * 在页面内动态配置导航条的时候需要使用此函数
     * @param {Emitter} _emitter
     */
    function setNaviagtionEmitter (_emitter) {
        return function (navigation) {
            // 为防止队列执行异常在下一个队列执行此操作
            setTimeout(() => _emitter.emit('nav-helper-scene-set-navigation', navigation), 0);
        };
    }

    /**
     * 在页面内动态配置导航条的时候需要使用此函数
     * @param {Emitter} _emitter
     */
    function setNaviagtionHideEmitter (_emitter) {
        return function (showStatus) {
            // 为防止队列执行异常在下一个队列执行此操作
            setTimeout(() => _emitter.emit('nav-helper-hide-header', showStatus), 0);
        };
    }

    /**
     * 在页面内动态配置导航条的时候需要使用此函数
     * @param {Emitter} _emitter
     */
    function setNaviagtionShowEmitter (_emitter) {
        return function () {
            // 为防止队列执行异常在下一个队列执行此操作
            setTimeout(() => _emitter.emit('nav-helper-show-header'), 0);
        };
    }

    /**
     * NavigationView 允许接收的属性类型
     */
    NavigationView.propTypes = {
        //hiddenHeader: PropTypes.bool, // 是否隐藏导航条
        headerStyle: View.propTypes.style, // 导航条外围容器的样式
        leftTextStyle: Text.propTypes.style, // 导航条左边文字的样式
        leftImgStyle: Image.propTypes.style, // 导航条左边图片样式
        leftArrowStyle: Image.propTypes.style, // 导航条左边箭头样式
        rightTextStyle: Text.propTypes.style, // 导航条右边文字样式
        rightImgStyle: Image.propTypes.style, // 导航条右边图片样式
        titleTextStyle: Text.propTypes.style, // 导航条中间文字样式
        titleImgStyle: Image.propTypes.style, // 导航条中间图片样式
        direction: PropTypes.oneOf([Directions.HORIZONTAL, Directions.VERTICAL]), // 导航条滑入的方向
        enableGestures: PropTypes.bool, // 是否允许手势触控,
    };

    NavigationView.defaultProps = {
        direction: Directions.HORIZONTAL,
        enableGestures: true
    };

    return (props) => {
        if(Platform.OS === 'ios') {
            return (
              <NavigatorIOS
                initialRoute={{
                    title: '',
                    passProps: props,
                    component: (_props) => {
                        return (
                          <NavigationView  {..._props} />
                        );
                    }
                }}
                style={{ flex: 1 }}
                navigationBarHidden={true}
              />
            );
        } else {
            return (
              <NavigationView  {...props}/>
            );
        }
    };
}


const styles = StyleSheet.create({
    container: {
        flex: 1,
        backgroundColor: Color.White1,
        flexDirection: 'column'
    },
    flex: {
        flex: 1
    },
    cardStyle: {
        elevation: 10,
    }
});

export default NavigationViewBuilder;