/**
 * 此文件为从 react-native 包中拷出来的导航动画文件
 * 截至 0.40.0 版本官方文件目录 node_modules/react-native/Libraries/CustomComponents/NavigationExperimental/NavigationCardStackStyleInterpolator.js
 * 官方只提供从右向左及从下往上两种动画格式，此文件提供对这两种动画的动画细节行进扩展的hack，主要为了适应公司原有App的导航过渡动画
 */

import {
    I18nManager
} from 'react-native';

/**
 * Utility that builds the style for the card in the cards stack.
 *
 *     +------------+
 *   +-+            |
 * +-+ |            |
 * | | |            |
 * | | |  Focused   |
 * | | |   Card     |
 * | | |            |
 * +-+ |            |
 *   +-+            |
 *     +------------+
 */

/**
 * Render the initial style when the initial layout isn't measured yet.
 */
function forInitial(props) {
	const {
		navigationState,
		scene,
	} = props;

	const focused = navigationState.index === scene.index;
	const opacity = focused ? 1 : 0;
	// If not focused, move the scene to the far away.
	const translate = focused ? 0 : 1000000;
	return {
		opacity,
		transform: [
			{ translateX: translate },
			{ translateY: translate },
		],
	};
}

function forHorizontal(props) {
	const {
		layout,
		position,
		scene,
	} = props;

	if (!layout.isMeasured) {
		return forInitial(props);
	}

	const index = scene.index;
	const inputRange = [index - 1, index, index + 0.99, index + 1];
	const width = layout.initWidth;
	const outputRange = I18nManager.isRTL ?
		[-width, 0, width / 2, 0] :
		[width, 0, -width / 2, -0];

	const opacity = position.interpolate({
		inputRange,
		outputRange: [1, 1, 0.3, 0],
	});

	const translateY = 0;
	const translateX = position.interpolate({
		inputRange,
		outputRange,
	});

	return {
		opacity,
		transform: [
			{ translateX },
			{ translateY },
		],
	};
}

function forVertical(props) {
	const {
		layout,
		position,
		scene,
	} = props;

	if (!layout.isMeasured) {
		return forInitial(props);
	}

	const index = scene.index;
	const inputRange = [index - 1, index, index + 0.99, index + 1];
	const height = layout.initHeight;

	const opacity = position.interpolate({
		inputRange,
		outputRange: [0.9, 1, 0.8, 0],
	});

	const translateY = position.interpolate({
		inputRange,
		outputRange: [height, 0, 0, 0],
	});

	return {
		opacity,
		transform: [
			{ translateY },
		],
	};
}

function canUseNativeDriver(isVertical) {
	// The native driver can be enabled for this interpolator because the scale,
	// translateX, and translateY transforms are supported with the native
	// animation driver.

	return true;
}

export default {
	forHorizontal,
	forVertical,
	canUseNativeDriver,
};
