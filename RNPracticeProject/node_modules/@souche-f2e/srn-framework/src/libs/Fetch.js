import {
    NativeModules,
    Platform,
    DeviceEventEmitter
} from 'react-native';

import SRNConfig from '../modules/SRNConfig';
import SRNNative from '@souche-f2e/srn-native';
import stacktraceParser from "stacktrace-parser";

const parseParam = function (obj) {
    return Object.keys(obj).map(k => {
        return k + '=' + encodeURIComponent(obj[k])
    }).join('&');
};
var reloginCallbacks = []
var hasPopupLogin = false;
const SRNNativeUtil = {
    getAppData: function (cb) {
        NativeModules.SCCRNAppData.getAppData(function (err, data) {
            if(err) {
                // TODO 怎么处理
            }
            cb && cb(null, data);
        });
    },
    reLogin: function (cb) {
        reloginCallbacks.push(cb);
        if(!hasPopupLogin) {
            hasPopupLogin = true;
            NativeModules.SCCRNOpenVCBridge.OpenVCBridge({
                protocol: global.LOGIN_PROTOCOL || ''
            }, () => {

                setTimeout(() => {
                    hasPopupLogin = false;
                    this.getAppData(() => {
                        while(reloginCallbacks.length > 0) {
                            var _cb = reloginCallbacks.shift()
                            _cb && _cb();
                        }
                    });

                }, 100)
            });
        }
    }

}


var APP_DATA = NativeModules.SCCRNAppData || {
      env: 0,
      userToken: ''
  };

var showToast = function(str = "", traceId = "") {
    if (global.SHOW_NETWORK_ERROR_TOAST !== false) {
        SRNNative.Loading.hide();
        setTimeout(() => {
            NativeModules.SCCRNModuleBridge.ModuleBridge({
                protocol: NativeModules.SCCRNAppData.appScheme + '://open/wirelessToast',
                data: {
                    text: str || '',
                    icon: traceId ? 'qrcode' : '',
                    duration: 2000,
                    qrcodeText: traceId
                }
            }, (err, res) => {
            });
        }, 200);
    }
};
const getDefaultHeader = function (token = '', appName = 'undefined') {
    return {
        'Authorization': 'Token token=' + token,
        'Token': token,
        'appname': appName,
        'appscheme': NativeModules.SCCRNAppData.appScheme,
        'TT': token,
        'Agent': (Platform.OS === 'ios') ? 11 : 10,
        '_security_token': token,
        '_security_token_inc': token,
        'Souche-Security-Token': token,
        'Souche-Inc-Security-Token': token,
        'souche-std-response': 1,
        'User-Agent': SRNConfig.ua,
        'Version': SRNConfig.hostAppVersion,
        'BundleVersion': SRNConfig.appVersion
    };
};
const isDev = (APP_DATA.env == 0);

const SRNFetch = function () {
    var options;
    if(arguments[1]) {
        options = arguments[1];
    } else {
        options = {};
    }

    if(!options.headers) {
        options.headers = {};
    }

    var timeout = options.timeout || 60000;
    var _args = arguments;
    var self = this;
    var stackTemp = stacktraceParser.parse(new Error().stack)[1];
    delete stackTemp.file;
    var stack = JSON.stringify(stackTemp);
    return new Promise((resolve, reject) => {
        var hasResolved = false;
        var hasRejected = false;
        SRNNativeUtil.getAppData(function (err, data) {
            // 附加token到header
            var token = data.userToken || 'empty_token';

            options.headers = Object.assign(options.headers, getDefaultHeader(token, data.appName));
            //本地开发调试环境，删掉 User-Agent 属性，以避免开启允许浏览器跨域后 在 Chrome DevTools 中调试网络请求时的 'Refused to set unsafe header "user-agent"'报错
            if (__DEV__) { delete options.headers["User-Agent"]; }
            var method = options.method ? options.method.toUpperCase() : 'GET';
            if(method === 'POST') {
                options.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
            if(options.json) {
                options.headers['Content-Type'] = 'application/json';
                options.body = JSON.stringify(options.json, undefined, 0)
            } else if(options.data) {
                if(method === 'GET') {
                    _args[0] = _args[0] + (_args[0].indexOf('?') === -1 ? '?' : '&') + parseParam(options.data);
                } else if(method === 'POST') {
                    if(typeof(options.data) == 'object') {
                        var formdata = new FormData();
                        for(var i in options.data) {
                            formdata.append(i, options.data[i]);
                        }
                        options.body = parseParam(options.data);
                    } else {
                        options.body = options.data;
                    }
                }
            } else {
                options.body = options.data;
            }

            _args[1] = options;
            var fetchStatus = 200;

             // 记录网络请求日志
            let fetchLogObj = { url: _args[0], options: _args[1] };
            SRNNative.log && SRNNative.log("v", `request=${JSON.stringify(fetchLogObj)}`, `[SRN-Network 发送请求] stack=${stack}`);

            if(timeout) {
                setTimeout(() => {
                    if(!hasResolved && !hasRejected) {
                        hasRejected = true;
                        var e = new Error('timeout');
                        e.code = 408;
                        showToast(`请求超时，请稍后再试`);
                        SRNNative.log && SRNNative.log("v", `request=${JSON.stringify(fetchLogObj)}`, `[SRN-Network 请求超时] stack=${stack}`, `等待时间为${timeout}ms，错误信息：${e.toString()}`);
                        reject(e);
                    }
                }, timeout);
            }
            fetch(_args[0], options).then((res) => {
                fetchStatus = res.status;
                return res.json();
            }).then((data) => {
                if(fetchStatus != 200) {
                    var e = new Error('系统错误，请稍后重试');
                    e.code = fetchStatus;
                    SRNNative.log && SRNNative.log("v", `request=${JSON.stringify(fetchLogObj)}`, `[SRN-Network 系统错误] stack=${stack}`, `错误信息：${e.toString()}`);
                    throw e;
                } else {
                    if(typeof(data.code) == 'undefined' && typeof(data.success) == 'undefined') {
                        // 兼容一些不标准的返回结构，直接抛出整个data
                        if(!hasResolved && !hasRejected) {
                            hasResolved = true;
                            SRNNative.log && SRNNative.log("v", `request=${JSON.stringify(fetchLogObj)}&response=${JSON.stringify(data)}`, `[SRN-Network 后台返回非标准结构数据] stack=${stack}`);
                            resolve(data);
                        }

                    } else {
                        // 标准结构的处理
                        if(parseInt(data.code) === 10000 || data.success) {
                            if(!hasResolved && !hasRejected) {
                                hasResolved = true;
                                SRNNative.log && SRNNative.log("v", `request=${JSON.stringify(fetchLogObj)}&response=${JSON.stringify(data.data)}`, `[SRN-Network 后台返回标准结构数据] stack=${stack}`);
                                resolve(data.data);
                            }

                        } else {
                            // 后台返回错误的处理
                            SRNNative.log && SRNNative.log("v", `request=${JSON.stringify(fetchLogObj)}`, `[SRN-Network 后台返回错误] stack=${stack}`, `错误信息：${JSON.stringify(data)}`);
                            if((parseInt(data.code) == 10001 || parseInt(data.code) == 10004) && global.LOGIN_PROTOCOL) {
                                hasRejected = true;
                                SRNNativeUtil.reLogin(() => {
                                    SRNFetch.apply(this, _args).then((data) => {
                                        resolve(data);
                                    }).catch((e) => {
                                        reject(e);
                                    })
                                })
                            } else {
                                data.message = data.msg;
                                throw data;
                            }
                        }
                    }
                }
            }).catch((e) => {
                if(e instanceof SyntaxError) {
                    SRNNative.log && SRNNative.log("v", `request=${JSON.stringify(fetchLogObj)}`, `[SRN-Network 解析出错] stack=${stack}`, `错误信息：${e.toString()}`);
                    showToast(`网络错误：解析出错`)
                } else {
                     if (e.message === "Network request failed") {
                       SRNNative.log && SRNNative.log("v", `request=${JSON.stringify(fetchLogObj)}`, `[SRN-Network 连接网络失败] stack=${stack}`, `错误信息：${e.toString()}`);
                       showToast("网络信号异常，连接网络失败");
                     } else {
                       SRNNative.log && SRNNative.log("v", `request=${JSON.stringify(fetchLogObj)}`, `[SRN-Network 其他网络问题] stack=${stack}`, `错误信息：${e.toString()}`);
                       showToast(e.message, e.traceId || "");
                     }
                }
                if(!hasResolved && !hasRejected) {
                    hasRejected = true;
                    reject(e);
                }
            });
        })

    })
};
export default SRNFetch;
