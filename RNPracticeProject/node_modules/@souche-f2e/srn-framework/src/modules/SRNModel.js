import price from './decorators/Unit/price';
import distance from './decorators/Unit/distance';
import UnitType from './decorators/Unit/UnitType';
import checker from './decorators/Check/checker';

class SRNModel {

    __mapping(json) {
        let self = Object.assign({}, this);
        let alias = this.constructor.__aliasNames__;
        let units = this.constructor.__unitOriginals__;
        let checkers = this.constructor.__checkers__;
        for (let i in this) {
            // if(!this.hasOwnProperty(i)) return; mobx @observable 修饰过的属性在此处 会直接 return，除非之前调用了 this[i] 这个 getter。
            let realValue;
            if (json.hasOwnProperty(i)) {
                realValue = json[i];
            } else {
                realValue = this[i];
            }
            // 接下来一步一步处理数据

            // 首先检查别名数据，并做映射
            if (alias && typeof alias[i] !== "undefined") {
                realValue = json[alias[i]];
            }
            // 然后针对数据检查类型
            if (checkers && checkers[i]) {
                var type = checkers[i].type;
                let shouldWarn = checker(realValue, type);
                if (shouldWarn) {
                    console.warn(`${this.constructor.name} 的属性 ${i} 类型错误，试图赋值类型 ${typeof realValue}:${realValue}，接受的类型 ${checkers[i].type}`);
                }
                // 如果属性应该是对象，但是值是空，设置成 {}
                if (type === "object") {
                    if (realValue === null || typeof realValue !== "object") {
                        console.warn(`对 ${this.constructor.name} 的属性 ${i} 进行强制转换，目标值:${realValue} 转换后的值：{}`);
                        realValue = {};
                    }
                }
                // 如果属性应该是数组，但是值是空，设置成 []
                if (type === "array") {
                    if (realValue === null || !Array.isArray(realValue)) {
                        console.warn(`对 ${this.constructor.name} 的属性 ${i} 进行强制转换，目标值:${realValue} 转换后的值：[]`);
                        realValue = [];
                    }
                }
            }
            // 最终，对数据做单位转换
            if (units && units[i]) {
                if (!/_\$.+$/.test(json[i])) {
                    console.warn(`服务端未配置此属性的单位注解: ${i}`);
                }
                let unitType = units[i].type;
                switch (unitType) {
                    case UnitType.PRICE_UNIT_F:
                    case UnitType.PRICE_UNIT_Y:
                    case UnitType.PRICE_UNIT_WY:
                        realValue = price(realValue, unitType);
                        break;
                    case UnitType.MILEAGE_UNIT_M:
                    case UnitType.MILEAGE_UNIT_KM:
                    case UnitType.MILEAGE_UNIT_WKM:
                        realValue = distance(realValue, unitType);
                        break;
                    default:
                        console.warn("error decorator unit type");
                }
            }
            // 赋值
            self[i] =  realValue;
        }
        return self;
    }

    __map(json) {
        let alias = this.constructor.__aliasNames__;
        let units = this.constructor.__unitOriginals__;
        let checkers = this.constructor.__checkers__;
        for (let i in this) {
            // if(!this.hasOwnProperty(i)) return; mobx @observable 修饰过的属性在此处 会直接 return，除非之前调用了 this[i] 这个 getter。
            let realValue;
            if (json.hasOwnProperty(i)) {
                realValue = json[i];
            } else {
                realValue = this[i];
            }
            // 接下来一步一步处理数据

            // 首先检查别名数据，并做映射
            if (alias && typeof alias[i] !== "undefined") {
                realValue = json[alias[i]];
            }
            // 然后针对数据检查类型
            if (checkers && checkers[i]) {
                var type = checkers[i].type;
                let shouldWarn = checker(realValue, type);
                if (shouldWarn) {
                    console.warn(
                        `${
                            this.constructor.name
                        } 的属性 ${i} 类型错误，试图赋值类型 ${typeof realValue}:${realValue}，接受的类型 ${
                            checkers[i].type
                        }`
                    );
                }
                // 如果属性应该是对象，但是值是空，设置成 {}
                if (type === "object") {
                    if (realValue === null || typeof realValue !== "object") {
                        console.warn(
                            `对 ${
                                this.constructor.name
                            } 的属性 ${i} 进行强制转换，目标值:${realValue} 转换后的值：{}`
                        );
                        realValue = {};
                    }
                }
                // 如果属性应该是数组，但是值是空，设置成 []
                // 如果属性应该是对象，但是值是空，设置成 {}
                if (type === "array") {
                    if (realValue === null || !Array.isArray(realValue)) {
                        console.warn(
                            `对 ${
                                this.constructor.name
                            } 的属性 ${i} 进行强制转换，目标值:${realValue} 转换后的值：[]`
                        );
                        realValue = [];
                    }
                }
            }
            // 最终，对数据做单位转换
            if (units && units[i]) {
                if (!/_\$.+$/.test(json[i])) {
                    console.warn(`服务端未配置此属性的单位注解: ${i}`);
                }
                let unitType = units[i].type;
                switch (unitType) {
                    case UnitType.PRICE_UNIT_F:
                    case UnitType.PRICE_UNIT_Y:
                    case UnitType.PRICE_UNIT_WY:
                        realValue = price(realValue, unitType);
                        break;
                    case UnitType.MILEAGE_UNIT_M:
                    case UnitType.MILEAGE_UNIT_KM:
                    case UnitType.MILEAGE_UNIT_WKM:
                        realValue = distance(realValue, unitType);
                        break;
                    default:
                        console.warn("error decorator unit type");
                }
            }
            // 赋值
            this[i] = realValue;
            setTimeout(()=> console.warn("[srn-framework] SRNModel 原 __map 方法在页面渲染时存在性能问题，建议使用 __mapping 方法，详见SRNModel文档"), 0)
        }
    }

    toJSON() {
        let result = {};
        let units = this.constructor.__unitOriginals__;
        for (let i in this) {
            // if (!this.hasOwnProperty(i)) continue;
            if (units && units[i]) {
                result[i] = this[i] + "_$" + units[i].type;
            } else {
                result[i] = this[i];
            }
        }
        return result;
    }
}

export default SRNModel;
