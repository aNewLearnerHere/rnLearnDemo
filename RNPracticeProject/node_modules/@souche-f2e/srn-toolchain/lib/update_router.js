'use strict';

const fs = require('fs');
const path = require('path');

const glob = require('glob');
const moment = require('moment');
const globalData = require("./global_data");
const pkg = require(globalData.PROJECT_PACKAGE_JSON);

/**
 * TODO 感觉改一下目录结构最方便, app.js router_config.js 放在最外层
 */

/**
 * 获取源码文件夹
 *      src 文件夹为主工程文件夹
 *      xx_src 为合作方开发的代码文件夹（xx 只能为字母）
 */
function getSrcFolders () {
    const projectDir = process.cwd();

    let srcFolders = [];

    try {
        const files = fs.readdirSync(projectDir, {
            encoding: 'utf8'
        });

        if (files && Array.isArray(files)) {
            srcFolders = files.filter(v => /^([\w]+_)?src/.test(v));
        }
    } catch (e) {
        return [];
    }

    return srcFolders;
}

/**
 * 将 file path 转为对象，主要生成 route_config.js 文件需要的内容
 */
function convertFilename (filename, absolutePageDir, srcFolder) {
    let routePath = '';
    let moduleName = '';
    let filePath = '';

    filename = filename.replace(/\/index\.(js|jsx)$/, '');

    routePath = filename.replace(absolutePageDir, '').replace('.js', '');
    moduleName = routePath.replace(/\//g, '_');

    if (srcFolder === 'src') {
        filePath = `./pages${routePath}`;
    } else {
        filePath = `../${srcFolder}/pages${routePath}`;
    }

    return {
        routePath: routePath,
        filePath: filePath,
        moduleName: moduleName
    };
}

/**
 * 检查路由是否有冲突
 */
function checkRouteConflict (allEntries) {
    let hasConfilct = false;
    const existRoute = {};

    allEntries.forEach(v => {
        if (!existRoute[v.routePath]) {
            existRoute[v.routePath] = v.filePath;
        } else {
            hasConfilct = true;
            process.stdout.write(`Error: ${v.filePath} and ${existRoute[v.routePath]} has same route \n`);
        }
    });

    return hasConfilct;
}

/**
 * 获取路由的入口文件
 */
function getRouteEntries () {
    const projectDir = process.cwd();
    const srcFolders = getSrcFolders();
    let allEntries = [];

    if (Array.isArray(srcFolders) && srcFolders.length <= 0) {
        return [];
    }

    srcFolders.forEach(srcFolder => {
        const pageDir = `./${srcFolder}/pages`;
        const absolutePageDir = path.resolve(projectDir, pageDir);

        // glob.sync 返回的是绝对路径
        let entries = glob.sync(absolutePageDir + '/**/*.+(js|jsx)');

        // pages/components 文件夹下的文件，不会作为路由入口文件
        entries = entries.filter(v => !/components/.test(v));
        entries = entries.map(filename => convertFilename(filename, absolutePageDir, srcFolder));
        allEntries = allEntries.concat(entries);
    });

    if (checkRouteConflict(allEntries)) {
        return [];
    }

    return allEntries;
}

/**
 * 更新路由文件
 */
function updateRouter () {
    const time = moment().format('YYYY-MM-DD HH:mm:ss');
    process.stdout.write(`[${time}] <START> Update Router Config File\n`);

    const routes = [];
    const imports = [];
    const entries = getRouteEntries();

    // 遍历 src/pages 下的文件
    entries.forEach(function (fileObj) {
        imports.push(`import ${fileObj.moduleName} from '${fileObj.filePath}';`);
        routes.push(`routeConfig['${fileObj.routePath}'] = ${fileObj.moduleName};`);
    });

    const routerFile = path.resolve(process.cwd(), './src/route_config.js');
    const routerContent = 'var routeConfig = {};\n\n' +
        imports.join('\n') + '\n\n' +
        routes.join('\n') + '\n\n' +
        'export default routeConfig;';

    fs.writeFileSync(routerFile, routerContent, 'utf8');

    process.stdout.write(`[${time}] <End> Update Router Config File\n`);

    // 更新 native_route_config.json 文件
    if (fs.existsSync(path.resolve(process.cwd(), "./src/native_route_config.json"))) {
        process.stdout.write(`[${time}] <START> Update native_route_config.json\n`);
        // 存在 native_route_config.json 则读取该文件
        const nativeRouteConfig = JSON.parse(fs.readFileSync(path.resolve(process.cwd(), "./src/native_route_config.json"), "utf8"));
        // 使用 route_config 中的 routePath 生成映射数据，同时保留 native_route_config.json 中相同 routePath 的原映射数据
        const nativeRouter = [];
        const nativeRouteConfigRoutes = nativeRouteConfig.map(router => router.route);
        entries.forEach(function(fileObj) {
            let index = nativeRouteConfigRoutes.indexOf(fileObj.routePath);
            index > -1 ? nativeRouter.push(nativeRouteConfig[index]) : nativeRouter.push(nativeRouterObj(fileObj));
        });
        //更新 native_route_config.json
        fs.writeFileSync(path.resolve(process.cwd(), "./src/native_route_config.json"), JSON.stringify(nativeRouter, null, "\t"), "utf8");
        process.stdout.write(`[${time}] <End> Update native_route_config.json\n`);
    }
}

/**
 * 更新 Native 映射文件
 */
function updateNativeRouter () {
    const time = moment().format("YYYY-MM-DD HH:mm:ss");
    process.stdout.write(`[${time}] <START> Create native_route_config.json\n`);
    const nativeRouter = [];
    const entries = getRouteEntries();
    // 如果 native_route_config.json 不存在则新建文件并写入 RN 中所有 route 映射后的数据
    if (!fs.existsSync(path.resolve(process.cwd(), "./src/native_route_config.json"))) {
        entries.forEach(function(fileObj) {
            nativeRouter.push(nativeRouterObj(fileObj));
        });
        fs.writeFileSync(path.resolve(process.cwd(), "./src/native_route_config.json"), JSON.stringify(nativeRouter, null, "\t"), "utf8");
        process.stdout.write(`[${time}] <End> Create native_route_config.json\n`);
    } else {
        // 存在 native_route_config.json 则读取该文件
        const nativeRouteConfig = JSON.parse(fs.readFileSync(path.resolve(process.cwd(), "./src/native_route_config.json"), "utf8"));

        // 筛选定义了 module 的 nativeRouter
        const nativeRouter = nativeRouteConfig.filter(route => route.module);
        // 检查筛选后的 nativeRouter 是否有重复定义的 module
        let existRepeat = false;
        const noRepeat = [];
        nativeRouter.map(route => {
            if (noRepeat.indexOf(route.module) > -1) {
                process.stdout.write(`\n Error: native_route_config.json 中 module: ${route.module} 重复定义 \n\n`);
                existRepeat = true;
                return;
            }
            noRepeat.push(route.module);
        });
        // 存在重复定义的 module 则返回，不生成 rnjson 中的数据
        if (existRepeat) {
            return;
        }
        const module_info_path = path.resolve(process.cwd(), globalData.MODULE_INFO_PATH);
        const rnjson_path = path.resolve(process.cwd(), `./dist/${pkg.name}.rnjson`);
        // 更新 module_info
        fs.existsSync(module_info_path) && writeNativeRouterInFile(module_info_path, nativeRouter);
        // 更新 rnjson
        fs.existsSync(rnjson_path) && writeNativeRouterInFile(rnjson_path, nativeRouter);
    }
}

/**
 *  写入 nativeRouter 到文件中
 */
function writeNativeRouterInFile (filePath, nativeRouter) {
    const time = moment().format("YYYY-MM-DD HH:mm:ss");
    process.stdout.write(`[${time}] <START> Update nativeRouter in ${filePath} File\n`);
    const fileContent = JSON.parse(fs.readFileSync(filePath, "utf8"));
    fileContent.nativeRouter = nativeRouter;
    fs.writeFileSync(filePath, JSON.stringify(fileContent, undefined, "\t"), "utf8");
    process.stdout.write(`[${time}] <End> Update nativeRouter in ${filePath} File\n`);
}

/**
 * Native Router 映射数据对象模板
 */
function nativeRouterObj (fileObj){
        return {
                "module": "",
                "method": "open",
                "desc": "",
                "route": fileObj.routePath,
                "params": {},
                "callbacks": {}
            }
    }

module.exports = {
    updateRouter: updateRouter,
    updateNativeRouter: updateNativeRouter,
    getSrcFolders: getSrcFolders
};
