/*global ErrorUtils:false*/

/**
 * react-native plugin for Raven
 *
 * Usage:
 *   var Raven = require('raven-js');
 *   Raven.addPlugin(require('raven-js/plugins/react-native'));
 *
 * Options:
 *
 *   pathStrip: A RegExp that matches the portions of a file URI that should be
 *     removed from stacks prior to submission.
 *
 *   onInitialize: A callback that fires once the plugin has fully initialized
 *     and checked for any previously thrown fatals.  If there was a fatal, its
 *     data payload will be passed as the first argument of the callback.
 *
 */
'use strict';
import {NativeModules, Platform} from 'react-native';
import {Sentry} from './Sentry';

function wrappedCallback(callback) {
  function dataCallback(data, original) {
    var normalizedData = callback(data) || data;
    if (original) {
      return original(normalizedData) || normalizedData;
    }
    return normalizedData;
  }
  return dataCallback;
}

// Example React Native path format (iOS):
// /var/containers/Bundle/Application/{DEVICE_ID}/HelloWorld.app/main.jsbundle

var PATH_STRIP_RE = /^.*\/[^\.]+(\.app|CodePush|.*(?=\/))/;
var FATAL_ERROR_KEY = '--rn-fatal--';
var ASYNC_STORAGE_KEY = '--raven-js-global-error-payload--';

/**
 * Strip device-specific IDs from React Native file:// paths
 */
function normalizeUrl(url, pathStripRe) {
  // sentry sourcemap 文件匹配的方式是：
  // 上报的异常中包含transaction字段，即表示那个bundle运行文件报错了，
  // 然后sentry依据当前release下的artifacts中找到当前dist的bundle文件，
  // bundle中是有sourceMapUrl标记的，所以在找到相应的sourcemap，
  // 从而定位异常的源码出处, 执行默认transaction的值就是当前执行bundle的名字
  // 所以的保证上传的bundle和执行的bundle名字一致，但不好修改以前的宿主APP中
  // 执行bundle的名字, 这里的每次js中修改transaction保持一致吧

  // return 'app://' + url.replace(/^file\:\/\//, '').replace(pathStripRe, '');

  // 只处理js错误，那一定是出自bundle文件，所以就以这样名字与sentry上一致吧
  // 这里取自打包时的node环境变量，静态代码替换，而非运行时变量
  // 依赖于：babel-plugin-transform-inline-environment-variables
  // 且只在当前包中配置了 .babelrc
  if ( process.env.SRN_FULL_BUNDLE ) {
    return `app:///index.${Platform.OS}.jsbundle`;
  } else {
    return `app:///index.${Platform.OS}.smallest.jsbundle`;
  }
}

/**
 * Extract key/value pairs from an object and encode them for
 * use in a query string
 */
function urlencode(obj) {
  var pairs = [];
  for (var key in obj) {
    if ({}.hasOwnProperty.call(obj, key))
      pairs.push(encodeURIComponent(key) + '=' + encodeURIComponent(obj[key]));
  }
  return pairs.join('&');
}

/**
 * Initializes React Native plugin
 */
function reactNativePlugin(Raven, options, internalDataCallback) {
  options = options || {};

  // Use data callback to strip device-specific paths from stack traces
  Raven.setDataCallback(
    wrappedCallback(function(data) {
      data = reactNativePlugin._normalizeData(data, options.pathStrip);
      if (internalDataCallback) {
        internalDataCallback(data);
      }
    })
  );

  if (options.nativeClientAvailable === false) {
    // react-native doesn't have a document, so can't use default Image
    // transport - use XMLHttpRequest instead
    Raven.setTransport(reactNativePlugin._transport);

    // Check for a previously persisted payload, and report it.
    reactNativePlugin._restorePayload().then(function(payload) {
      if (!payload) return;

      var { dsn, data } = payload;

      options.onInitialize && options.onInitialize(data);
      // use previous bundle's dsn 解决同一个宿主APP中运行多个bundle的情况
      options.dsn !== dsn && Raven.setDSN( dsn );

      Raven._sendProcessedPayload(data, function(error) {
        if (error) return; // Try again next launch.
        reactNativePlugin._clearPayload();
      });

      // retrive current bundle's dsn
      options.dsn !== dsn && Raven.setDSN( options.dsn );
    })['catch'](function() {});

    Raven.setShouldSendCallback(function(data, originalCallback) {
      if (!(FATAL_ERROR_KEY in data)) {
        // not a fatal (will not crash runtime), continue as planned
        return originalCallback ? originalCallback.call(this, data) : true;
      }

      var origError = data[FATAL_ERROR_KEY];
      delete data[FATAL_ERROR_KEY];

      // 通过dsn, 解决同一个宿主APP中运行多个bundle的情况
      reactNativePlugin._persistPayload({
          dsn: options.dsn,
          data: data
      }).then(function() {
        defaultHandler(origError, true);
        handlingFatal = false; // In case it isn't configured to crash.
        return null;
      })['catch'](function() {});

      return false; // Do not continue.
    });
  }

  // Make sure that if multiple fatals occur, we only persist the first one.
  //
  // The first error is probably the most important/interesting error, and we
  // want to crash ASAP, rather than potentially queueing up multiple errors.
  var handlingFatal = false;

  var defaultHandler =
    (ErrorUtils.getGlobalHandler && ErrorUtils.getGlobalHandler()) ||
    ErrorUtils._globalHandler;

  if (options.handlePromiseRejection) {
    // Track unhandled promise rejections
    var tracking = require('promise/setimmediate/rejection-tracking');
    tracking.disable();
    tracking.enable({
      allRejections: true,
      onUnhandled: function(id, error) {
        var captureOptions = {
          timestamp: new Date() / 1000,
          type: 'Unhandled Promise Rejection'
        };
        Raven.captureException(error, captureOptions);
      },
      onHandled: function() {}
    });
  }

  ErrorUtils.setGlobalHandler(function(error, isFatal) {
    var captureOptions = {
      timestamp: new Date() / 1000
    };
    var error = arguments[0];
    if (isFatal) {
      captureOptions.level = 'fatal';
    }
    // We want to handle fatals, but only in production mode.
    var shouldHandleFatal = isFatal && !global.__DEV__;
    if (shouldHandleFatal) {
      if (handlingFatal) {
        console.log('Encountered multiple fatals in a row. The latest:', error);
        return;
      }
      handlingFatal = true;
      // We need to preserve the original error so that it can be rethrown
      // after it is persisted (see our shouldSendCallback above).
      captureOptions[FATAL_ERROR_KEY] = error;
    }
    Raven.captureException(error, captureOptions);
    if (options.nativeClientAvailable) {
      // We always want to tunnel errors to the default handler
      Sentry._setInternalEventStored(() => {
        defaultHandler(error, isFatal);
      });
    } else {
      // if we don't have a native
      defaultHandler(error, isFatal);
    }
  });
}

/**
 * Saves the payload for a globally-thrown error, so that we can report it on
 * next launch.
 *
 * Returns a promise that guarantees never to reject.
 */
reactNativePlugin._persistPayload = function(payload) {
  var AsyncStorage = require('react-native').AsyncStorage;
  return AsyncStorage.setItem(ASYNC_STORAGE_KEY, JSON.stringify(payload))[
    'catch'
  ](function() {
    return null;
  });
};

/**
 * Checks for any previously persisted errors (e.g. from last crash)
 *
 * Returns a promise that guarantees never to reject.
 */
reactNativePlugin._restorePayload = function() {
  var AsyncStorage = require('react-native').AsyncStorage;
  var promise = AsyncStorage.getItem(ASYNC_STORAGE_KEY).then(function(payload) {
    return JSON.parse(payload);
  })['catch'](function() {
    return null;
  });
  // Make sure that we fetch ASAP.
  var RCTAsyncSQLiteStorage = NativeModules.AsyncSQLiteDBStorage;
  var RCTAsyncRocksDBStorage = NativeModules.AsyncRocksDBStorage;
  var RCTAsyncFileStorage = NativeModules.AsyncLocalStorage;
  var RCTAsyncStorage =
    RCTAsyncRocksDBStorage || RCTAsyncSQLiteStorage || RCTAsyncFileStorage;
  if (RCTAsyncStorage.multiGet) {
    AsyncStorage.flushGetRequests();
  }

  return promise;
};

/**
 * Clears any persisted payloads.
 */
reactNativePlugin._clearPayload = function() {
  var AsyncStorage = require('react-native').AsyncStorage;
  return AsyncStorage.removeItem(ASYNC_STORAGE_KEY)['catch'](function() {
    return null;
  });
};

/**
 * Custom HTTP transport for use with React Native applications.
 */
reactNativePlugin._transport = function(options) {
  var request = new XMLHttpRequest();
  request.onreadystatechange = function(e) {
    if (request.readyState !== 4) {
      return;
    }

    if (request.status === 200) {
      if (options.onSuccess) {
        options.onSuccess();
      }
    } else {
      if (options.onError) {
        var err = new Error('Sentry error code: ' + request.status);
        err.request = request;
        options.onError(err);
      }
    }
  };

  request.open('POST', options.url + '?' + urlencode(options.auth));

  // NOTE: React Native ignores CORS and will NOT send a preflight
  //       request for application/json.
  // See: https://facebook.github.io/react-native/docs/network.html#xmlhttprequest
  request.setRequestHeader('Content-type', 'application/json');

  // Sentry expects an Origin header when using HTTP POST w/ public DSN.
  // Just set a phony Origin value; only matters if Sentry Project is configured
  // to whitelist specific origins.
  request.setRequestHeader('Origin', 'react-native://');

  // captureException 或 运行异常时，sentry 原来上报和显示数据格式如下，
  // data = { ..., exception: { values: [{ stacktrace: [], type: 'Error', value: 'error message'  }]  }, ... }
  // 这里可以修改 type = type + ': ' + value; 便于问题区别
  var values = options.data.exception && options.data.exception.values;
  if ( values ) {
    values.forEach( v => {
      v.type = v.type + ': ' + v.value;
    });
  }

  request.send(JSON.stringify(options.data));
};

/**
 * Strip device-specific IDs found in transaction and frame filenames
 * when running React Native applications on a physical device.
 */
reactNativePlugin._normalizeData = function(data, pathStripRe) {
  if (!pathStripRe) {
    pathStripRe = PATH_STRIP_RE;
  }

  if (data.culprit) {
    data.culprit = normalizeUrl(data.culprit, pathStripRe);
  }

  if (data.transaction) {
    data.transaction = normalizeUrl(data.transaction, pathStripRe);
  }

  // NOTE: if data.exception exists, exception.values and exception.values[0] are
  // guaranteed to exist
  var stacktrace =
    data.stacktrace || (data.exception && data.exception.values[0].stacktrace);
  if (stacktrace) {
    stacktrace.frames.forEach(function(frame) {
      if (frame.filename !== '[native code]') {
        frame.filename = normalizeUrl(frame.filename, pathStripRe);
      }
    });
  }
  return data;
};

module.exports = reactNativePlugin;
