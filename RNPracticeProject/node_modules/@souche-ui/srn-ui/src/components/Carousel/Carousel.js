import React from 'react';
import {
    View,
    ScrollView,
    ViewPagerAndroid,
    Platform,
    TouchableOpacity,
} from 'react-native';
import PropTypes from 'prop-types';
import styleUtil from '../../util/styleUtil';
import theme from '../../theme';

class Carousel extends React.Component {
    constructor(props) {
        super(props);

        this.state = {
            index: this.convertIndex(this.fixedIndex(props)),
            width: 1,
            animating: false,
        };

        this.handleChange = this.handleChange.bind(this);
    }

    componentWillReceiveProps(nextProps) {
        if (this.props.defaultIndex !== nextProps.defaultIndex) {
            this.setState({
                index: this.convertIndex(this.fixedIndex(nextProps))
            });
        }
    }

    componentDidMount() {
        if (this.props.autoPlay) {
            this.autoPlayTimer = setInterval(() => {
                // 滚动到下一页
                this.scrollTo({ index: this.recoverIndex(this.state.index) + 1 });
            }, this.props.duration);
        }
    }

    componentWillUnmount() {
        if (this.autoPlayTimer) {
            clearInterval(this.autoPlayTimer);
        }
    }

    /**
     * 修正 defaultIndex 值
     * @param {*} props 组件参数
     */
    fixedIndex(props) {
        const { defaultIndex, children } = props;

        // 处理 defaultIndex 大于最大位置的情况
        if (children.length > 0) {
            return defaultIndex % children.length;
        } else {
            return defaultIndex;
        }
    }

    /**
     * 将视觉上的位置转换为逻辑上的位置
     */
    convertIndex(index) {
        // 由于默认是循环轮播的，头尾会存在占位轮播图，所以需要将视觉上的位置处理成实际的位置
        return index + 1;
    }

    /**
     * 将视觉上的长度转换为逻辑上的长度
     */
    convertLength(length) {
        // 由于默认是循环轮播的，头尾会存在占位轮播图，所以逻辑上的长度会比视觉大 2 个单位
        return length + 2;
    }

    /**
     * 将逻辑上的位置恢复成视觉上的位置
     */
    recoverIndex(index) {
        return index - 1;
    }

    /**
     * 滚动到指定位置
     * @param {*} param
     * @param {number} param.index 指定的位置（视觉上的位置）
     * @param {boolean} param.animated 是否启用平滑滚动动画
     */
    scrollTo({ index, animated = true }) {
        const logicIndex = this.convertIndex(index) % this.convertLength(this.props.children.length);
        if (Platform.OS === 'ios') {
            this.scrollView.scrollTo({
                x: logicIndex * this.state.width,
                y: 0,
                animated
            });
            if (!animated) {
                this.handleChange(logicIndex);
            }
        } else {
            if (animated) {
                this.scrollView.setPage(logicIndex);
                // 由于 setPage 方法在滚动动画完成后不会触发 onPageSelected，也没有回调参数
                // 所以不能调用 handleChange
                // 需要立一个 flag，之后通过 onPageScrollStateChanged，判断 flag 后调用 handleChange
                this.stashedIndex = logicIndex;
                this.needUpdate = 1;
            } else {
                this.scrollView.setPageWithoutAnimation(logicIndex);
                this.handleChange(logicIndex);
            }
        }
    }

    handlePageScrollStateChange(status) {
        if (this.autoPlayTimer && status === 'dragging') {
            // 用户拖动操作打断自动轮播动画
            clearInterval(this.autoPlayTimer);
        }
        if (this.needUpdate > 0 && status === 'idle') {
            // scrollTo 方法中如果立了 flag，并且动画已结束，则放下 flag，并调用 handleChange 方法
            this.needUpdate = 0;
            this.handleChange(this.stashedIndex);
        }
    }

    /**
     * 切换到指定位置，在不需要触发 onChange 的情况下使用，内部使用
     * @param {*} param
     * @param {number} param.index 指定的位置（逻辑上的位置）
     */
    scrollToWithoutTriggerChange({ index }) {
            this.setState({
                index
            });
        if (Platform.OS === 'android') {
            // andoird 上只能通过 ViewPagerAndroid 的实例方法切换位置
            this.scrollView.setPageWithoutAnimation(index);
        }
    }

    handleAnimationBegin() {
        this.setState({ animating: true });
    }

    handleChange(index) {
        const { onChange, children } = this.props;
        const prevIndex = this.state.index;
        const length = this.convertLength(children.length);
        // 向上取整，处理自动轮播时，用户的拖动操作导致滚动错位问题
        let nextIndex = Math.ceil(index);
        this.setState({ animating: false });

        if (prevIndex !== nextIndex) {
            // 循环轮播逻辑
            // 处理滚动到头尾的占位轮播图时，需要切换到视觉位置上的对应轮播图
            if (index === 0) {
                // 如果滚动到头部占位图，则切换到视觉位置的最后一张图
                nextIndex = length - 2;
            }
            if (index === length - 1) {
                // 如果滚动到尾部占位图，则切换到视觉位置的第一张图
                nextIndex = 1;
            }
            this.scrollToWithoutTriggerChange({ index: nextIndex });
            onChange && onChange(this.recoverIndex(nextIndex), this.recoverIndex(prevIndex));
        }
    }

    handlePress(index) {
        this.props.onPress && this.props.onPress(this.recoverIndex(index));
    }

    /**
     * 渲染轮播图底片
     * @param {*} children 组件子元素
     */
    renderFilm(children) {
        const length = React.Children.count(children);
        if (length === 0) {
            return null;
        }
        // 为了实现循环轮播的效果，在轮播图底片的头和尾接上占位图，分别是原底片的尾和头
        return React.Children.map([children[length - 1]].concat(children, children[0]), (child, i) => {
            return (
                <View key={i} style={[styles.childWrapper, this.props.style, { width: this.state.width }]}>
                    <TouchableOpacity
                        activeOpacity={1}
                        onPress={() => { this.handlePress(i); }}
                    >{child}</TouchableOpacity>
                </View>
            );
        });
    }

    /**
     * 轮播图位置指示器
     */
    renderIndicator() {
        const { showIndicator, indicatorStyle, indicatorActiveStyle } = this.props;
        if (showIndicator === false) {
            return;
        }

        return (
            <View style={styles.indicator}>
                {React.Children.map(this.props.children, (v, i) => {
                    const active = this.recoverIndex(this.state.index) === i;
                    return (
                        <View key={i} style={[
                            styles.indicatorDot,
                            active && styles.activeIndicator,
                            active ? indicatorActiveStyle : indicatorStyle,
                        ]}/>
                    );
                })}
            </View>
        );
    }

    /**
     * 轮播图播放器
     */
    renderPlayer() {
        const {
            children
        } = this.props;

        if (Platform.OS === 'ios') {
            return (
                <ScrollView
                    ref={c => { this.scrollView = c; }}
                    horizontal={true}
                    pagingEnabled={true}
                    scrollEventThrottle={10}
                    showsHorizontalScrollIndicator={false}
                    bounces={false}
                    scrollEnabled={!this.state.animating}
                    contentOffset={{x: this.state.index * this.state.width, y: 0}}
                    onMomentumScrollBegin={() => this.handleAnimationBegin()}
                    onMomentumScrollEnd={(e)=> this.handleChange(e.nativeEvent.contentOffset.x / this.state.width)}
                    onLayout={(e) => this.setState({ width: e.nativeEvent.layout.width })}
                    onScrollBeginDrag={(e) => this.handlePageScrollStateChange('dragging')}
                >
                    {this.renderFilm(children)}
                </ScrollView>
            );
        } else {
            // Android 上也可以用 ScrollView，但是设置初始位置无效，因为 Android 上不能滚动到未渲染的位置
            // 在内容渲染完再设置会造成闪烁，因此选择 ViewPagerAndroid 代替
            return (
                <ViewPagerAndroid
                    ref={c => { this.scrollView = c; }}
                    style={styles.container}
                    initialPage={this.state.index}
                    keyboardDismissMode="on-drag"
                    onPageSelected={(e) => this.handleChange(e.nativeEvent.position)}
                    onPageScrollStateChanged={(e) => this.handlePageScrollStateChange(e)}
                >
                    {this.renderFilm(children)}
                </ViewPagerAndroid>
            );
        }
    }

    render() {
        return (
            <View style={styles.container}>
                {this.renderPlayer()}
                {this.renderIndicator()}
            </View>
        );
    }
}

Carousel.propTypes = {
    defaultIndex: PropTypes.number,
    showIndicator: PropTypes.bool,
    autoPlay: PropTypes.bool,
    duration: PropTypes.number,
    onPress: PropTypes.func,
    onChange: PropTypes.func,
    style: View.propTypes.style,
    indicatorStyle: View.propTypes.style,
    indicatorActiveStyle: View.propTypes.style,
};

Carousel.defaultProps = {
    defaultIndex: 0,
    showIndicator: true,
    autoPlay: false,
    duration: 3000,
    children: [],
};

const styles = styleUtil.create({
    common: {
        container: {
            flex: 1,
        },
        childWrapper: {
            alignItems: 'stretch'
        },
        indicator: {
            position: 'absolute',
            left: 0,
            right: 0,
            bottom: 0,
            height: 19,
            flexDirection: 'row',
            justifyContent: 'center',
            alignItems: 'center'
        },
        indicatorDot: {
            width: 7,
            height: 7,
            borderRadius: 7,
            backgroundColor: theme('color_white'),
            opacity: 0.4,
            marginLeft: 4.5,
            marginRight: 4.5
        },
        activeIndicator: {
            opacity: 1,
        },
    }
});

export default Carousel;