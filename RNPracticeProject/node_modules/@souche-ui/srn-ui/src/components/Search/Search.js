import React from 'react';
import {
    View,
    Text,
    TouchableOpacity,
    TextInput,
    ScrollView,
    TouchableWithoutFeedback,
    Image,
    InteractionManager,
    Platform,
    StyleSheet,
} from 'react-native';
import PropTypes from 'prop-types';
import FontSize from '../../const/FontSize';
import theme from '../../theme';
import Icon from '../Icon/Icon';
import Popover from '../Popover';

class Search extends React.Component{
    constructor(props){
        super(props);
        this.state = {
            value: this.props.defaultValue || '',      // Input 中的值
        };

        this._onChangeText = this._onChangeText.bind(this);
        this._onClear = this._onClear.bind(this);
        this._searchSubmit = this._searchSubmit.bind(this);
    }
    componentWillReceiveProps(nextProps){
        if (nextProps.defaultValue !== this.props.defaultValue || nextProps.defaultValue !== undefined) {
            this.setState({
                value: nextProps.defaultValue
            });
        }
    }

    componentDidMount() {
        /**
         * 在动画完后再唤起键盘，防止卡顿
         * TextInput 中不设置 autoFocus
         */
        InteractionManager.runAfterInteractions(() => {
            this.input && this.input.focus && this.input.focus();
        });
    }

    // Input 中的值变化回调函数，并执行外部的 onValueChange 回调
    _onChangeText(value){
        this.setState({value});
        // 给外部 onValueChange 一个节流
        clearTimeout(this.throttleId);
        this.throttleId = setTimeout(()=>{
            this.props.onValueChange && this.props.onValueChange(value);
        }, this.throttleDelay);
    }

    // 点击输入框后的清空按钮
    _onClear() {
        this.throttleId && clearTimeout(this.throttleId);
        this.setState({value: ''});
        this.props.onValueChange && this.props.onValueChange('');
    }

    // 点击软键盘上【搜索】键
    _searchSubmit(){
        this.throttleId && clearTimeout(this.throttleId);
        this.props.onSearch && this.props.onSearch(this.state.value);
    }

    // 渲染拓展型搜索栏左侧的分类选项
    _renderGroup(){
        // 通过 selectedGroup 传递过来的 value 值，找到对应的在 groups 数组中的索引 selectedIndex，若找不到，默认 selectedIndex = 0
        let groups = this.props.groups || [],
            selectedGroup = this.props.selectedGroup || '', i, selectedIndex;
        if (groups.length){
            for (i = 0; i < groups.length; i++){
                if (selectedGroup === groups[i].value){
                    selectedIndex = i;
                    break;
                }
            }
        }
        if (i >= groups.length) {selectedIndex = 0;}
        return (
            // 通过 groups.length 判断是否是拓展型，如果是拓展型，则渲染 Popover; 如果不是拓展型，则渲染 SearchIcon
            !groups.length ?
                <View style={styles.searchIcon}>
                    <Image
                        style={styles.searchIconImg}
                        resizeMode={'contain'}
                        source={{uri: 'https://assets.souche.com/assets/sccimg/common/newsearch.png'}}
                    />
                </View>
                :
                <Popover content={this._generatePopoverContent()} placement="bottom">
                    <View style={styles.searchGroup}>
                        <Text style={styles.groupText}>{groups[selectedIndex].label}</Text>
                        <Icon type="caretDown" size="xxs"/>
                        <View style={styles.vLine}/>
                    </View>
                </Popover>
        );
    }
    // 生成 Group 内容
    _generatePopoverContent(){
        let groups = this.props.groups;
        if (groups.length){
            return (
                <Popover.Menu>
                    {groups.map((item, index)=>{
                        return <Popover.Menu.Item key={index} onPress={this._popoverPress.bind(this, index)}>{item.label}</Popover.Menu.Item>;
                    })}
                </Popover.Menu>
            );
        }
    }
    // 点击 Group 中的某一项，执行外部传递进来的 onGroupChange 回调
    _popoverPress(selectedIndex){
        let group = this.props.groups[selectedIndex];
        this.props.onGroupChange && this.props.onGroupChange(group);
    }

    _renderTextInput(){
        this.throttleDelay = this.props.throttleDelay || 0;      // valueChange 函数触发的节流延迟时间
        // 搜索框获取焦点事件
        let { onFocus } = this.props;
        return (
                <TextInput
                    ref={c => { this.input = c; }}
                    style={[
                        styles.searchInput,
                        Platform.OS === 'ios' && styles.fixInput  // ios 上 textInput 不能竖直居中
                    ]}
                    onChangeText={this._onChangeText}
                    onFocus={onFocus}
                    value={this.state.value}
                    placeholder={this.props.placeholder || ''}
                    placeholderTextColor={theme('color_text_hint')}
                    // autoFocus={true}
                    returnKeyType={'search'}
                    returnKeyLabel={'search'}
                    onSubmitEditing={this._searchSubmit}
                    underlineColorAndroid={'transparent'}  // android取消文本框下划线
                />
        );
    }
    _renderCancelIcon(){
        // 通过 this.state.value 来判断是否需要渲染搜索框最后的 清空Icon
        return (
            this.state.value ?
                <TouchableOpacity onPress={this._onClear}>
                    <View style={styles.cancelIcon}>
                        <Icon type="closeCircle" size="md" color={theme('color_text_caption')}/>
                    </View>
                </TouchableOpacity>
                :
                null
        );
    }

    /**
     this.props.section 的情况分三种
     1. 对象数组
     section = [
        {title: '', icon: <Icon/>, items: ['奔驰', '宝马', '奥迪']},
        ...
     ]

     2. 字符串
     section = '抱歉，暂无相关品牌或车系'

     3. 自定义组件
     section = <View/>
     */
    _renderSection(){
        const section = this.props.section || [];
        if (section instanceof Array){
            return (
                <ScrollView
                    keyboardShouldPersistTaps={'handled'}
                    keyboardDismissMode={'on-drag'}
                >
                    {
                        section.map((oneSection, index)=>{
                            return (
                                <Section
                                    key={index}
                                    title={oneSection.title}
                                    items={oneSection.items}
                                    icon={oneSection.icon}
                                    onSearch={this.props.onSearch}
                                    keyword={this.state.value}
                                />
                            );
                        })
                    }
                </ScrollView>
            );
        } else if (typeof section === 'string'){
            return (
                <View style={styles.sectionItemView}>
                    <View style={styles.itemTextView}>
                        <Text style={styles.sectionItem}>{section}</Text>
                    </View>
                </View>
            );
        } else {
            return section;
        }
    }

    render(){
        let pageFlexStyle = this.props.section ? {flex: 1} : null;    // 当没有 section 的时候，表明组件是页面内使用，不是跳转页面使用，组件不能撑满屏幕
        return (
            <View style={[styles.pageContainer, pageFlexStyle]}>
                <View style={styles.searchContainer}>
                    <View style={[styles.searchBox]}>
                        {this._renderGroup()}
                        {this._renderTextInput()}
                        {this._renderCancelIcon()}
                    </View>
                    <TouchableOpacity onPress={()=>{this.props.onCancelPress && this.props.onCancelPress();}}>
                        <Text style={styles.cancelText}>取消</Text>
                    </TouchableOpacity>
                </View>
                {
                    this.props.section ?
                        <View style={styles.scrollViewContainer}>
                            {this._renderSection()}
                        </View>
                        :
                        null
                }
            </View>
        );
    }
}

class Section extends React.Component{
    _onPress(index){
        this.props.onSearch && this.props.items && this.props.onSearch(this.props.items[index]);
    }
    _onPressIn(index){
        this[index].setNativeProps({style: {
            backgroundColor: theme('color_press'),
        }});
    }
    _onPressOut(index){
        this[index].setNativeProps({style: {
            backgroundColor: theme('color_white'),
        }});
    }
    _renderTitle(){
        return (
            this.props.title &&
            <View style={[styles.sectionItemView]}>
                <View style={[styles.itemTextView, styles.itemTitleView]}>
                    <Text style={[styles.sectionItem, {color: theme('color_text_caption')}]}>{this.props.title}</Text>
                    {this.props.icon}
                </View>
            </View>
        );
    }
    _renderItems(){
        const items = this.props.items;
        return (
            items && items.length > 0 && (items.map((item, index) => {
                return (
                    <TouchableWithoutFeedback
                        key={index}
                        onPressIn={this._onPressIn.bind(this, index)}
                        onPressOut={this._onPressOut.bind(this, index)}
                        onPress={this._onPress.bind(this, index)}
                    >
                        <View ref={(component)=>{this[index] = component;}} style={styles.sectionItemView}>
                            <View style={styles.itemTextView}>
                                <Text style={styles.sectionItem}>{item}</Text>
                            </View>
                        </View>
                    </TouchableWithoutFeedback>
                );
            }))
        );

        /*
        * 将 items 根据 keyword 切分后进行关键词高亮显示
        * */
        /*const items = this.keywordSplit(this.props.items, this.props.keyword);
        return (
            items && items.length && (items.map((item, index) => {
                return (
                    <TouchableWithoutFeedback
                        key={index}
                        onPressIn={this._onPressIn.bind(this, index)}
                        onPressOut={this._onPressOut.bind(this, index)}
                        onPress={this._onPress.bind(this, index)}
                    >
                        <View ref={(component)=>{this[index] = component;}} style={styles.sectionItemView}>
                            <View style={[styles.itemTextView, {flexDirection: 'row', alignItems: 'center', justifyContent: 'flex-start'}]}>
                                {item.map((label, labelIndex)=>{
                                    let highLight = (label === this.props.keyword ? {color: theme('color_primary_text')} : {});
                                    return <Text key={labelIndex} style={[styles.sectionItem, highLight]}>{label}</Text>;
                                })}
                            </View>
                        </View>
                    </TouchableWithoutFeedback>
                );
            }))
        );*/
    }
    render(){
        return (
            <View style={styles.sectionContainer}>
                {this._renderTitle()}
                {this._renderItems()}
            </View>
        );
    }

    /*
    * 将字符串数组按照关键词切分为二维数组，保留关键词，用于高亮匹配词汇
    * @params arr: string[], keyword: string
    * @return 二维数组
    * */
    /*keywordSplit(arr, keyword){
        let returnArr = [];
        const reg = new RegExp('(' + keyword + ')', 'i');   // 使用捕获型括号的正则匹配 split ,结果数组可以保留分隔符
        arr.forEach((item)=>{
            returnArr.push(item.split(reg));
        });
        return returnArr;
    }*/
}

Search.Indicator = (props) => {
    return (
        <View style={styles.indicatorContainer}>
            <View style={[styles.indicatorBox]}>
                <Image
                    style={styles.searchIconImg}
                    resizeMode={'contain'}
                    source={{uri: 'https://assets.souche.com/assets/sccimg/common/newsearch.png'}}
                />
                <View style={styles.interval}/>
                <Text style={styles.indicatorPlaceholder}>{props.placeholder}</Text>
            </View>
        </View>
    );
};

export default Search;

Search.propTypes = {
    placeholder: PropTypes.string,
    section: PropTypes.oneOfType([PropTypes.array, PropTypes.string, PropTypes.element]),
    onCancelPress: PropTypes.func,
    onValueChange: PropTypes.func,
    throttleDelay: PropTypes.number,
    onSearch: PropTypes.func,
    groups: PropTypes.array,
    selectedGroup: PropTypes.string,
    onGroupChange: PropTypes.func,
    onFocus: PropTypes.func
};
Search.Indicator.propTypes = {
    placeholder: PropTypes.string,
};

Search.defaultProps = {
    onFocus: () => {}
};

const styles = StyleSheet.create({
    pageContainer: {},
    searchContainer: {
        backgroundColor: theme('color_white'),
        height: 44,
        flexDirection: 'row',
        paddingLeft: 16,
        paddingRight: 16,
        justifyContent: 'center',
        alignItems: 'center',
        borderBottomWidth: 1,
        borderBottomColor: '#EAEAEA',
    },
    searchBox: {
        height: 30,
        flex: 1,
        flexDirection: 'row',
        alignItems: 'center',
        borderRadius: 15,
        backgroundColor: theme('color_background_page'),
    },
    searchIcon: {
        height: 30,
        justifyContent: 'center',
        paddingLeft: 16,
        paddingRight: 4
    },
    searchInput: {
        height: 30,
        flex: 1,
        fontSize: FontSize.P2,
        color: theme('color_text_title'),
        padding: 0,    // 兼容 android 文字不能显示全
    },
    fixInput: {
        paddingTop: 1.67,
    },
    cancelIcon: {
        height: 30,
        justifyContent: 'center',
        paddingRight: 8
    },
    cancelText: {
        fontSize: FontSize.P1,
        color: theme('color_primary_text'),
        paddingLeft: 16,
    },
    sectionContainer: {
        backgroundColor: theme('color_white'),
    },
    sectionItemView: {
        height: 48,
        paddingLeft: 16
    },
    itemTextView: {
        height: 48,
        borderBottomWidth: 1,
        borderBottomColor: '#EAEAEA',
        justifyContent: 'center',
    },
    itemTitleView: {
        flexDirection: 'row',
        justifyContent: 'space-between',
        alignItems: 'center',
        paddingRight: 18
    },
    sectionItem: {
        fontSize: FontSize.P1,
        color: theme('color_text_title'),
    },
    searchGroup:{
        flexDirection: 'row',
        alignItems: 'center',
        paddingLeft: 12,
    },
    groupText: {
        fontSize: FontSize.P2,
        color: theme('color_text_title'),
        marginRight: 6
    },
    vLine: {
        height: FontSize.P2,
        width: 0,
        borderLeftWidth: 1,
        borderLeftColor: theme('color_press'),
        marginLeft: 12,
        marginRight: 12,
    },
    indicatorContainer: {
        height: 44,
        flexDirection: 'row',
        paddingLeft: 16,
        paddingRight: 16,
        justifyContent: 'center',
        alignItems: 'center',
    },
    indicatorBox: {
        height: 30,
        flex: 1,
        flexDirection: 'row',
        borderRadius: 15,
        backgroundColor: theme('color_background_page'),
        justifyContent: 'flex-start',
        alignItems: 'center',
        paddingLeft: 16,
        paddingRight: 16,
    },
    indicatorPlaceholder: {
        fontSize: FontSize.P2,
        color: theme('color_text_hint'),
    },
    searchIconImg: {
        width: 16,
        height: 16,
    },
    scrollViewContainer: {
        flex: 1
    },
    interval: {
        width: 4
    }
});
