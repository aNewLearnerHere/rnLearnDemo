import React, {Component} from 'react';
import { View, StyleSheet, Text, TouchableWithoutFeedback } from 'react-native';
import PropTypes from 'prop-types';

import DatePickerBody from '../PickerBody/DatePickerBody';
import Popup from '../Popup';
import FontSize from '../../const/FontSize';
import theme from '../../theme';

export default class DateRangePicker extends Component{
    constructor(props){
        super(props);
        const [{ date: startDate }, { date: endDate }] = this.generatorParams(props);
        this.state = {
            visible: this.props.visible || false,
            selectedDate: [startDate, endDate],
        };
    }

    componentWillReceiveProps(nextProps){
        const [{ date: startDate }, { date: endDate }] = this.generatorParams(nextProps);
        this.setState({
            visible: nextProps.visible || false,
            selectedDate: [startDate, endDate],
        });
    }

    /**
     * 处理参数
     * */
    generatorParams(props){
        const params = [];
        const {
            mode,
            defaultDate = [undefined, undefined],
            minimumDate = [undefined, undefined],
            maximumDate = [undefined, undefined],
        } = props;
        if (defaultDate.length !== 2) {
            console.warn('DateRangePicker: defaultDate 属性不为空时，数组长度必须为 2');
        }
        if (minimumDate.length !== 2) {
            console.warn('DateRangePicker: minimumDate 属性不为空时，数组长度必须为 2');
        }
        if (maximumDate.length !== 2) {
            console.warn('DateRangePicker: maximumDate 属性不为空时，数组长度必须为 2');
        }
        for (let i = 0; i < 2; i++) {
            const fixedProps = this.fixProps({
                mode: mode,
                defaultDate: defaultDate[i],
                minimumDate: minimumDate[i],
                maximumDate: maximumDate[i],
            });
            params[i] = fixedProps;
        }
        return params;
    }

    fixProps(props) {
        let date = props.defaultDate || new Date();
        const mode = props.mode;
        let minimumDate = props.minimumDate;
        if (!minimumDate){
            if (mode === 'datetime') {
                minimumDate = new Date(date.getTime() - 30 * 24 * 3600000);
            } else {
                minimumDate = new Date(date.getTime() - 3650 * 24 * 3600000);
            }
        }
        if (date.getTime() < minimumDate.getTime()) {
            date = minimumDate;
        }
        let maximumDate = props.maximumDate;
        if (!maximumDate) {
            if (mode === 'datetime') {
                maximumDate = new Date(date.getTime() + 30 * 24 * 3600000);
            } else {
                maximumDate = new Date(date.getTime() + 3650 * 24 * 3600000);
            }
        }
        if (maximumDate.getTime() < minimumDate.getTime()) {
            maximumDate = minimumDate;
        }
        if (date.getTime() > maximumDate.getTime()) {
            date = maximumDate;
        }

        return {minimumDate, maximumDate, date, mode};
    }

    render(){
        const [startProps, endProps] = this.generatorParams(this.props);
        return (
            <Popup visible={this.state.visible} onClose={this.onCancelPress}>
                <View style={styles.datePickerContainer}>
                    <View style={styles.datePickerTitleContainer}>
                        <TouchableWithoutFeedback onPress={this.onCancelPress}>
                            <View style={styles.cancelContainerStyle}>
                                <Text style={styles.cancelAndConfirmTextStyle}>取消</Text>
                            </View>
                        </TouchableWithoutFeedback>
                        <View style={styles.titleContentContainer}>
                            {
                                typeof (this.props.title) === 'string' ?
                                    <Text>{this.props.title}</Text>
                                    :
                                    <View>{this.props.title}</View>
                            }
                        </View>
                        <TouchableWithoutFeedback onPress={this.onConfirmPress}>
                            <View style={styles.confirmContainerStyle}>
                                <Text style={styles.cancelAndConfirmTextStyle}>确定</Text>
                            </View>
                        </TouchableWithoutFeedback>
                    </View>
                    <View style={styles.pickerBodyContainer}>
                        <View style={styles.pickerBodyWrapper}>
                            <DatePickerBody
                                {...startProps}
                                date={this.state.selectedDate[0]}
                                onDateChange={selectedDate => this.onDateChange(selectedDate, 'start')}
                            />
                        </View>
                        <View style={styles.pickerBodyWrapper}>
                            <DatePickerBody
                                {...endProps}
                                date={this.state.selectedDate[1]}
                                onDateChange={selectedDate => this.onDateChange(selectedDate, 'end')}
                            />
                        </View>
                    </View>
                </View>
            </Popup>
        );
    }

    onDateChange = (selectedDate, range) => {
        this.setState(prevState => {
            if (range === 'start' && selectedDate > prevState.selectedDate[1]) {
                // 如果本次改变的是开始日期且开始日期大于结束日期，就把结束日期改成开始日期的值
                return {
                    selectedDate: [selectedDate, selectedDate],
                };
            } else if (range === 'end' && prevState.selectedDate[0] > selectedDate) {
                // 如果本次改变的是结束日期且开始日期大于结束日期，就把结束日期改成开始日期的值
                return {
                    selectedDate: [prevState.selectedDate[0], prevState.selectedDate[0]],
                };
            } else {
                // 否则正常更新开始日期和结束日期
                return {
                    selectedDate: range === 'start' ?
                        [selectedDate, prevState.selectedDate[1]] :
                        [prevState.selectedDate[0], selectedDate],
                };
            }
        });
    };

    onCancelPress = () => {
        this.props.onCancelPress && this.props.onCancelPress(this.state.selectedDate);
    };

    onConfirmPress = () => {
        this.props.onConfirmPress && this.props.onConfirmPress(this.state.selectedDate);
    };
}

DateRangePicker.propTypes = {
    visible: PropTypes.bool,
    minimumDate: PropTypes.arrayOf(PropTypes.instanceOf(Date)),
    maximumDate: PropTypes.arrayOf(PropTypes.instanceOf(Date)),
    mode: PropTypes.oneOf(['year']).isRequired,
    defaultDate: PropTypes.arrayOf(PropTypes.instanceOf(Date)),
    onDateChange: PropTypes.func,
    title: PropTypes.oneOfType([
        PropTypes.string,
        PropTypes.element
    ]),
    onConfirmPress: PropTypes.func,
    onCancelPress: PropTypes.func,
};

const styles = StyleSheet.create({
    datePickerContainer: {
        alignSelf: 'stretch'
    },
    datePickerTitleContainer: {
        height: 44,
        backgroundColor: theme('color_background_block'),
        borderTopWidth: StyleSheet.hairlineWidth,
        borderTopColor: '#c1c1c1',
        borderBottomWidth: StyleSheet.hairlineWidth,
        borderBottomColor: '#c1c1c1',
        flexDirection: 'row',
        alignItems: 'stretch',
    },
    cancelContainerStyle: {
        justifyContent: 'center',
        paddingLeft: 16,
        paddingRight: 24,
    },
    titleContentContainer: {
        flex: 1,
        justifyContent: 'center',
        alignItems: 'center',
    },
    confirmContainerStyle: {
        justifyContent: 'center',
        paddingLeft: 24,
        paddingRight: 16,
    },
    cancelAndConfirmTextStyle: {
        color: theme('color_primary'),
        fontSize: FontSize.P1,
    },
    pickerBodyContainer: {
        flex: 1,
        flexDirection: 'row',
    },
    pickerBodyWrapper: {
        flex: 1,
    },
});