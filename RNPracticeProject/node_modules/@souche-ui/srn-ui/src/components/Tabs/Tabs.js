import React from 'react';
import {
  View,
  Dimensions,
  Animated,
  TouchableOpacity,
  ScrollView,
  ViewPagerAndroid,
  InteractionManager,
  Platform,
  UIManager,
  LayoutAnimation,
} from 'react-native';
import PropTypes from 'prop-types';

import styleUtil from '../../util/styleUtil';
import commonStyles from './styles/index.style';
import theme from '../../theme';

const styles = styleUtil.create({
    common: commonStyles,
});

const INDICATOR_BAR_EXTRA_WIDTH = 8;
const TAB_PADDING = 24 - INDICATOR_BAR_EXTRA_WIDTH;

class Tabs extends React.Component {
    constructor(props) {
        super(props);
        if (Platform.OS === 'android') {
          UIManager.setLayoutAnimationEnabledExperimental && UIManager.setLayoutAnimationEnabledExperimental(props.enableLayoutAnimation);
        }
        this.scrollableViewRef;
        this.tabsWidthTempArr = [];
        this.tabsXTempArr = [];
        this.tabsXTextTempArr = [];
        this.tabsXTabTempArr = [];
        this.windowWidth = Dimensions.get('window').width;
        const tabsTextAndView = props.tabsView || props.tabsText;
        this.tabsLength = tabsTextAndView.length;
        this.onFirstScroll = true;
        this.setActiveIndex(props.defaultIndex);
        this.state = {
            tabsTextAndView,
            tabActivedIndex: props.defaultIndex,
            tabMinWidth: Math.floor(this.windowWidth / this.tabsLength),
            tabWidth: 0,
            tabsWidthArr: [],
            tabsXArr: [],
            tabsXTabArr: [],
            tabsXTextArr: [],
            moveValue: new Animated.Value(0),
            widthValue: new Animated.Value(0),
        };
        this.onScroll = this.onScroll.bind(this);
    }

    componentWillReceiveProps(nextProps) {
        if (nextProps.tabsView !== this.props.tabsView ||
            nextProps.tabsText !== this.props.tabsText) {
                const tabsTextAndView = nextProps.tabsView || nextProps.tabsText;
                const tabsLength = tabsTextAndView.length;
                this.setState({
                    tabsTextAndView,
                    tabMinWidth: Math.floor(this.windowWidth / tabsLength),
                });
        }
        if (nextProps.defaultIndex !== this.props.defaultIndex) {
            const nextIndex = nextProps.defaultIndex;
            if (nextProps.scrollable) {
                this.setActiveIndex(nextIndex);
                this.adjustTabsPosition(nextIndex);
            } else {
                this.setActiveIndexForUnscrollable(nextIndex);
            }
        }
    }

    setActiveIndex(index) {
        this.tabActivedIndex = index;
    }

    setActiveIndexForUnscrollable(index) {
        this.setState({
            tabActivedIndex: index,
            tabWidth: this.state.tabsWidthArr[index] || 0,
        });
        Animated.timing(this.state.moveValue, {
            toValue: this.state.tabsXTabArr[index] + this.state.tabsXTextArr[index],
            duration: 100,
            useNativeDriver: true //删掉会有UI block风险
        }).start();
    }

    onTextLayout(event,i) {
        const tabActivedIndex = this.props.scrollable ? this.tabActivedIndex : this.state.tabActivedIndex;
        this.tabsWidthTempArr[i] = Math.floor(event.nativeEvent.layout.width) + INDICATOR_BAR_EXTRA_WIDTH;
        this.tabsXTextTempArr[i] = Math.floor(event.nativeEvent.layout.x) - INDICATOR_BAR_EXTRA_WIDTH / 2;
        InteractionManager.runAfterInteractions(() => {
            this.setState({
                tabsWidthArr: this.tabsWidthTempArr,
                tabsXTextArr: this.tabsXTextTempArr,
                tabWidth: this.state.tabsWidthArr[tabActivedIndex] || 0,
            }, () => {
                // 移动底部衬线，如果和 adjustTabsPosition 调用写在一起会导致底部衬线移动到坐标为 0 的位置
                this.moveTabUnderline(tabActivedIndex);
                if (this.state.tabsWidthArr.length === this.tabsLength && Array.from(this.state.tabsWidthArr).every(n => n !== undefined) && !this.isAllLayouted) {
                    this.isAllLayouted = true;
                    if (this.isAllTabLayouted) {
                        // 在所有的 tab 和 text 都 layout 完成后，调整 tabs 滚动位置
                        this.adjustTabsPosition(tabActivedIndex);
                    }
                }
            });
        });
    }

    onTabLayout(event,i) {
        const tabActivedIndex = this.props.scrollable ? this.tabActivedIndex : this.state.tabActivedIndex;
        this.tabsXTabTempArr[i] = Math.floor(event.nativeEvent.layout.x);
        InteractionManager.runAfterInteractions(() => {
            this.setState({
                tabsXTabArr: this.tabsXTabTempArr,
            }, () => {
                if (this.state.tabsXTabArr.length === this.tabsLength && Array.from(this.state.tabsXTabArr).every(n => n !== undefined) && !this.isAllTabLayouted) {
                    this.isAllTabLayouted = true;
                    if (this.isAllLayouted) {
                        // 在所有的 tab 和 text 都 layout 完成后，调整 tabs 滚动位置并且移动底部衬线
                        this.adjustTabsPosition(tabActivedIndex);
                        this.moveTabUnderline(tabActivedIndex);
                    }
                }
            });
        });
    }
    onPress(i) {
        this.onPressEvent = true;
        this.setActiveIndex(i);
        this.setState({tabActivedIndex: i}); //scrollable为false时，通过setState直接切换tab对应的view（不可见经过内容）
        if (this.props.scrollable){
            this.scrollTo({ index: i, x: this.windowWidth * i, y: 0, animated: true }); //scrollable为true时，通过scrollableViewRef滚动切换到tab对应的view（可见经过内容）
            this.adjustTabsPosition(i);
        }
        if (this.props.enableLayoutAnimation) {
            let CustomLayoutLinear = {
                duration: 100,
                create: {
                    type: LayoutAnimation.Types.linear,
                    property: LayoutAnimation.Properties.scaleXY,
                },
                update: {
                    type: LayoutAnimation.Types.linear,
                },
            };
            LayoutAnimation.configureNext(CustomLayoutLinear);
        }
        this.setState({
          tabWidth: this.state.tabsWidthArr[i]
        });
        let tabX = this.state.tabsXTabArr[i] + this.state.tabsXTextArr[i];
        Animated.timing(
            this.state.moveValue,
            {
                toValue: tabX,
                duration: 200,
                useNativeDriver: true,      //删掉会有UI block风险
            }
        ).start();
        this.props.onPress(i);
    }

    onScroll(index){
        if (this.onFirstScroll) {
            this.onFirstScroll = false;
            index = this.props.defaultIndex;
        }

        if (this.onPressEvent) { return; }
        if (this.state.tabsWidthArr.length === 0) { return; }

        let tabX = this.state.tabsXTabArr[Math.floor(index)] + this.state.tabsXTextArr[Math.floor(index)];
        let tabsXOffset = this.state.tabsXTabArr.map((v, i) => {
            if (i) {
                return v - this.state.tabsXTabArr[i - 1];
            }
        }).filter(v => v);
        let move = (tabsXOffset[Math.floor(index)] * (index - Math.floor(index))) || 0;
        Animated.timing(this.state.moveValue, {
            toValue: tabX + move,
            duration: 100,
            useNativeDriver: true //删掉会有UI block风险
        }).start();
        if (this.props.enableLayoutAnimation) {
            let CustomLayoutLinear = {
                duration: 100,
                create: {
                    type: LayoutAnimation.Types.linear,
                    property: LayoutAnimation.Properties.scaleXY,
                },
                update: {
                    type: LayoutAnimation.Types.linear,
                },
            };
            LayoutAnimation.configureNext(CustomLayoutLinear);
        }

        let movingWidth = this.state.tabsWidthArr[Math.floor(index)] + this.state.tabsWidthArr[Math.round(index)] - this.state.tabsWidthArr[Math.floor(index)];
        this.setState({
          tabWidth: movingWidth,
        });
        // console.log('move',move);
        // console.log('index',index);
    }

    onMomentumScrollEnd(index) {
        this.onPressEvent = false;
        this.props.afterScrollActived(index);
        this.adjustTabsPosition(index);
    }

    scrollTo(option) {
        if (Platform.OS === 'ios') {
            this.scrollableViewRef && this.scrollableViewRef.scrollTo(option);
        } else {
            this.scrollableViewRef.setPage(option.index);
        }
    }

    adjustTabsPosition(index) {
        if (!this.tabsScrollViewRef || !this.props.scrollableTabs) {
            return;
        }
        const { tabsXTabArr, tabsWidthArr } = this.state;
        const tabOffsetX = tabsXTabArr[index];
        const tabWidth = tabsWidthArr[index] + TAB_PADDING;
        const fullWidth = tabsXTabArr[this.state.tabsXTabArr.length - 1] + tabsWidthArr[tabsWidthArr.length - 1] + TAB_PADDING;
        if (tabOffsetX > this.windowWidth / 2) {
            this.tabsScrollViewRef.scrollTo({
                x: Math.max(0, Math.min(fullWidth - this.windowWidth, tabOffsetX - this.windowWidth / 2 + tabWidth / 2)),
            });
        } else {
            this.tabsScrollViewRef.scrollTo({
                x: 0,
            });
        }
    }

    moveTabUnderline(index) {
        let tabX = this.state.tabsXTabArr[index] + this.state.tabsXTextArr[index];
        Animated.timing(
            this.state.moveValue,
            {
                toValue: isNaN(tabX) ? (this.state.tabsXTextArr[index] || 0) : tabX,
                duration: 200,
                useNativeDriver: true,      //删掉会有UI block风险
            }
        ).start();
    }

    renderScrollTabs() {
        if (Platform.OS === 'ios') {
            return (
                <ScrollView
                    ref={scrollableViewRef =>{this.scrollableViewRef = scrollableViewRef;}}
                    style={styles.scrollTabs}
                    contentContainerStyle={styles.scrollTabs}
                    onScroll={e => {this.onScroll(e.nativeEvent.contentOffset.x / this.windowWidth);}}
                    horizontal={true}
                    directionalLockEnabled={true}
                    showsHorizontalScrollIndicator={false}
                    automaticallyAdjustContentInsets={false}
                    bounces={false}
                    pagingEnabled={true}
                    scrollEventThrottle={16}
                    contentOffset={{x:this.props.defaultIndex * this.windowWidth, y: 0}}
                    onMomentumScrollEnd={(event)=>this.onMomentumScrollEnd(event.nativeEvent.contentOffset.x / this.windowWidth)}
                    >
                    {
                        this.state.tabsTextAndView && this.state.tabsTextAndView.map((tab, index)=>{
                            const view = typeof tab.view === 'function' ? tab.view() : tab.view;
                            return (
                                <View style={{width: this.windowWidth}} key={index}>{view}</View>
                            );
                        })
                    }
                </ScrollView>
            );
        } else if (Platform.OS === 'android') {
            return (
                <ViewPagerAndroid
                    ref={scrollableViewRef =>{this.scrollableViewRef = scrollableViewRef;}}
                    style={styles.pageContainer}
                    initialPage={this.props.defaultIndex}
                    keyboardDismissMode="on-drag"
                    onPageScroll={(e) => this.onScroll(e.nativeEvent.position + e.nativeEvent.offset)}
                    onPageSelected={(e) => this.onMomentumScrollEnd(e.nativeEvent.position)}
                >
                {
                    this.state.tabsTextAndView && this.state.tabsTextAndView.map((tab, index)=>{
                        const view = typeof tab.view === 'function' ? tab.view() : tab.view;
                        return (
                            <View style={{width: this.windowWidth}} key={index}>{view}</View>
                        );
                    })
                }
                </ViewPagerAndroid>
            );
        }
    }

    renderTabs() {
        if (this.props.scrollableTabs) {
            return (
                <View style={[styles.content]}>
                    <ScrollView
                        ref={tabsScrollViewRef => { this.tabsScrollViewRef = tabsScrollViewRef; }}
                        style={styles.scrollTabsContent}
                        horizontal={true}
                        directionalLockEnabled={true}
                        showsHorizontalScrollIndicator={false}
                        automaticallyAdjustContentInsets={false}
                        bounces={false}
                    >
                        <View>
                            <View style={[styles.tabs]}>
                                {
                                    this.state.tabsTextAndView && this.state.tabsTextAndView.map((renderTab, i) => {
                                        return (
                                            <TouchableOpacity style={{ minWidth: this.state.tabMinWidth }} activeOpacity={1} onPress={() => this.onPress(i)} key={i} onLayout={(e) => this.onTabLayout(e, i)}>
                                                <View style={[styles.tab]} >
                                                    <Animated.Text
                                                        style={[
                                                            styles.tabText,
                                                            {
                                                                color: theme('color_text_title'),
                                                            }
                                                        ]}
                                                        onLayout={(e) => this.onTextLayout(e, i)}
                                                    >{(this.props.tabsText && this.props.tabsText[i]) || (this.props.tabsView && renderTab.name)}</Animated.Text>
                                                </View>
                                            </TouchableOpacity>
                                        );
                                    })
                                }
                            </View>
                            <Animated.View style={[styles.tabsUnderline, { width: this.state.tabWidth }, {
                                transform: [
                                    { translateX: this.state.moveValue },
                                ]
                            }]} />
                        </View>
                    </ScrollView>
                </View>
            );
        } else {
            return (
                <View style={styles.content}>
                    <View style={styles.tabs}>
                        {
                            this.state.tabsTextAndView && this.state.tabsTextAndView.map((renderTab, i)=>{
                                return (
                                    <TouchableOpacity style={{minWidth: this.state.tabMinWidth}} activeOpacity={1} onPress={()=>this.onPress(i)} key={i} onLayout={(e)=>this.onTabLayout(e,i)}>
                                        <View style={[styles.tab]} >
                                            <Animated.Text
                                                        style={[
                                                            styles.tabText,
                                                            {
                                                                color: theme('color_text_title'),
                                                            }
                                                        ]}
                                                        onLayout={(e) => this.onTextLayout(e, i)}
                                                    >{(this.props.tabsText && this.props.tabsText[i]) || (this.props.tabsView && renderTab.name)}</Animated.Text>
                                        </View>
                                    </TouchableOpacity>
                                );
                            })
                        }
                    </View>
                    <Animated.View style={[styles.tabsUnderline,{width: this.state.tabWidth}, {transform: [
                            {translateX: this.state.moveValue}
                        ]}]}/>
                </View>
            );
        }
    }

    render() {
        return (
            <View style={styles.container}>
                {this.renderTabs()}
                {this.props.scrollable && this.renderScrollTabs()}
                {!this.props.scrollable && this.props.tabsText && this.props.children}
                {!this.props.scrollable && this.props.tabsView && this.props.tabsView[this.state.tabActivedIndex].view}
            </View>
        );
    }
}

Tabs.propTypes = {
    // tabsText:PropTypes.string,
    defaultIndex:PropTypes.number,
    // tabsView:PropTypes.element,
    scrollable:PropTypes.bool,
    enableLayoutAnimation:PropTypes.bool,
    onPress:PropTypes.func,
    afterScrollActived:PropTypes.func,
};
Tabs.defaultProps = {
    defaultIndex: 0,
    scrollable: false,
    enableLayoutAnimation: true,
    onPress: function() {},
    afterScrollActived: function() {},
};

export default Tabs;
