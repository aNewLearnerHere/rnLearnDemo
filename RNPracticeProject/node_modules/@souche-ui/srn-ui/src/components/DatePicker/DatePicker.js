import React, {Component} from 'react';
import {
    View,
    StyleSheet,
    Text,
    TouchableWithoutFeedback,
    Dimensions,
} from 'react-native';
import PropTypes from 'prop-types';

import DatePickerBody from '../PickerBody/DatePickerBody';
import Popup from '../Popup';
import Grid from '../Grid';
import Tag from '../Tag';
import FontSize from '../../const/FontSize';
import theme from '../../theme';

const SCREEN_WIDTH = Dimensions.get('window').width;

export default class DatePicker extends Component{
    constructor(props){
        super(props);
        const { date } = this.generatorParams(props);
        this.state = {
            visible: this.props.visible || false,
            selectedDate: date,
        };
    }

    componentWillReceiveProps(nextProps){
        const { date } = this.generatorParams(nextProps);
        this.setState({
            visible: nextProps.visible || false,
            selectedDate: date,
        });
    }

    /**
     * 处理参数
     * */
    generatorParams(props){
        let date = props.defaultDate || new Date();
        const mode = props.mode || 'date';
        let minimumDate = props.minimumDate;
        if (!minimumDate){
            if (mode === 'datetime') {
                minimumDate = new Date(date.getTime() - 30 * 24 * 3600000);
            } else {
                minimumDate = new Date(date.getTime() - 3650 * 24 * 3600000);
            }
        }
        if (date.getTime() < minimumDate.getTime()) {
            date = minimumDate;
        }
        let maximumDate = props.maximumDate;
        if (!maximumDate) {
            if (mode === 'datetime') {
                maximumDate = new Date(date.getTime() + 30 * 24 * 3600000);
            } else {
                maximumDate = new Date(date.getTime() + 3650 * 24 * 3600000);
            }
        }
        if (maximumDate.getTime() < minimumDate.getTime()) {
            maximumDate = minimumDate;
        }
        if (date.getTime() > maximumDate.getTime()) {
            date = maximumDate;
        }
        const minuteInterval = props.minuteInterval || 1;

        return {minimumDate, maximumDate, minuteInterval, date, mode};
    }

    renderShortcuts() {
        const { shortcuts, shortcutsPosition } = this.props;
        return shortcuts.length ? (
            <Grid
                style={[
                    styles.shortcuts,
                    shortcutsPosition === 'top' ? styles.shortcutsTop : styles.shortcutsBottom,
                ]}
                cols={4}
                width={SCREEN_WIDTH - 32}
                columnGap={8}
                rowGap={10}
            >
                {shortcuts.map(shortcut => (
                    <Tag
                        key={shortcut.name}
                        style={styles.shortcut}
                        autoWidth={false}
                        onSelect={() => this.onDateChange(shortcut.date)}
                    >{shortcut.name}</Tag>
                ))}
            </Grid>
        ) : null;
    }

    render(){
        const { minimumDate, maximumDate, minuteInterval, mode } = this.generatorParams(this.props);
        const { shortcutsPosition } = this.props;

        return (
            <Popup visible={this.state.visible} onClose={this.onCancelPress}>
                <View style={styles.datePickerContainer}>
                    <View style={styles.datePickerTitleContainer}>
                        <TouchableWithoutFeedback onPress={this.onCancelPress}>
                            <View style={styles.cancelContainerStyle}>
                                <Text style={styles.cancelAndConfirmTextStyle}>取消</Text>
                            </View>
                        </TouchableWithoutFeedback>
                        <View style={styles.titleContentContainer}>
                            {
                                typeof (this.props.title) === 'string' ?
                                    <Text>{this.props.title}</Text>
                                    :
                                    <View>{this.props.title}</View>
                            }
                        </View>
                        <TouchableWithoutFeedback onPress={this.onConfirmPress}>
                            <View style={styles.confirmContainerStyle}>
                                <Text style={styles.cancelAndConfirmTextStyle}>确定</Text>
                            </View>
                        </TouchableWithoutFeedback>
                    </View>
                    {shortcutsPosition === 'top' && this.renderShortcuts()}
                    <DatePickerBody
                        mode={mode}
                        date={this.state.selectedDate}
                        maximumDate={maximumDate}
                        minimumDate={minimumDate}
                        minuteInterval={minuteInterval}
                        onDateChange={this.onDateChange}
                    />
                    {shortcutsPosition === 'bottom' && this.renderShortcuts()}
                </View>
            </Popup>
        );
    }

    onDateChange = (selectedDate) => {
        if (selectedDate instanceof Date) {
            this.setState({selectedDate}, () => {
                this.props.onDateChange && this.props.onDateChange(this.state.selectedDate);
            });
        } else {
            this.props.onDateChange && this.props.onDateChange(selectedDate);
        }
    };

    onCancelPress = () => {
        this.props.onCancelPress && this.props.onCancelPress(this.state.selectedDate);
    };

    onConfirmPress = () => {
        this.props.onConfirmPress && this.props.onConfirmPress(this.state.selectedDate);
    };
}

DatePicker.propTypes = {
    visible: PropTypes.bool,
    minimumDate: PropTypes.instanceOf(Date),
    maximumDate: PropTypes.instanceOf(Date),
    mode: PropTypes.oneOf(['year', 'year-month', 'date', 'datetime', 'time']),
    minuteInterval: PropTypes.oneOf([1, 2, 3, 4, 5, 6, 10, 12, 15, 20, 30]),
    defaultDate: PropTypes.instanceOf(Date),
    onDateChange: PropTypes.func,
    title: PropTypes.oneOfType([
        PropTypes.string,
        PropTypes.element
    ]),
    shortcuts: PropTypes.arrayOf(PropTypes.shape({
        name: PropTypes.string,
        date: PropTypes.instanceOf(Date),
    })),
    shortcutsPosition: PropTypes.oneOf(['top', 'bottom']),
    onConfirmPress: PropTypes.func,
    onCancelPress: PropTypes.func,
};

DatePicker.defaultProps = {
    shortcuts: [],
    shortcutsPosition: 'bottom',
};

const styles = StyleSheet.create({
    datePickerContainer: {
        alignSelf: 'stretch'
    },
    datePickerTitleContainer: {
        height: 44,
        backgroundColor: theme('color_background_block'),
        borderTopWidth: StyleSheet.hairlineWidth,
        borderTopColor: '#c1c1c1',
        borderBottomWidth: StyleSheet.hairlineWidth,
        borderBottomColor: '#c1c1c1',
        flexDirection: 'row',
        alignItems: 'stretch',
    },
    cancelContainerStyle: {
        justifyContent: 'center',
        paddingLeft: 16,
        paddingRight: 24,
    },
    titleContentContainer: {
        flex: 1,
        justifyContent: 'center',
        alignItems: 'center',
    },
    confirmContainerStyle: {
        justifyContent: 'center',
        paddingLeft: 24,
        paddingRight: 16,
    },
    cancelAndConfirmTextStyle: {
        color: theme('color_primary_text'),
        fontSize: FontSize.P1,
    },
    shortcuts: {
        paddingHorizontal: 16,
        backgroundColor: '#ffffff',
    },
    shortcutsTop: {
        paddingTop: 16,
    },
    shortcutsBottom: {
        paddingBottom: 16,
    },
    shortcut: {
        height: 30,
    },
});