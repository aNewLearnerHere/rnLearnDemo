import React from 'react';
import {
    View,
    Text,
    FlatList,
    TouchableOpacity,
    Platform,
    StyleSheet,
    InteractionManager,
} from 'react-native';
import PropTypes from 'prop-types';
import MonthView from './MonthView';
import FontSize from '../../const/FontSize';
import theme from '../../theme';
import MonthHeader from './MonthHeader';
import DatePicker from '../DatePicker';
import { format, getDateRangeResult, getDateResult, addMonths, calculateDateRangeCount, getPureDay } from './date';
import Icon from '../Icon';

const MONTH_HEIGHT = 356;
const runAfterInteractions = f => {
    // ensure f get called, timeout at 500ms
    // @gre workaround https://github.com/facebook/react-native/issues/8624
    let called = false;
    const timeout = setTimeout(() => { called = true; f(); }, 500);
    InteractionManager.runAfterInteractions(() => {
        if (called) {
            return;
        }
        clearTimeout(timeout);
        f();
    });
};

class Calendar extends React.Component {
    constructor(props) {
        super(props);

        this.state = {
            monthList: [],
            value: this.fixValue(props),
            dateWithoutTime: null,
            timePickerVisible: false,
            timePickerState: 'single',
        };


        this.handleViewableItemsChanged = this.handleViewableItemsChanged.bind(this);
        this.handleSelect = this.handleSelect.bind(this);
        this.handleTimeSelect = this.handleTimeSelect.bind(this);
        this.handleCancelTimeSelect = this.handleCancelTimeSelect.bind(this);
        this.getMark = this.getMark.bind(this);
        this.renderItem = this.renderItem.bind(this);
    }

    componentWillReceiveProps(nextProps) {
        if (nextProps.defaultValue !== this.props.defaultValue) {
            this.setState({
                value: this.fixValue(nextProps),
            });
        }
    }

    componentDidMount() {
        runAfterInteractions(() => {
            setTimeout(() => {
                this.setState({
                    monthList: this.getMonthList(this.props),
                }, () => {
                    setTimeout(() => {
                        this.flatList && this.flatList.scrollToOffset({
                            offset: Math.max(0, this.props.pastScrollRange * MONTH_HEIGHT - 20),
                            animated: false,
                        });
                    }, 0);
                });
            }, 50);
        });
    }

    fixValue(props) {
        if (props.type === 'single') {
            return props.defaultValue ? props.inTransformer(props.defaultValue) : null;
        } else if (props.type === 'range') {
            if (!props.defaultValue) {
                return {start: null, end: null};
            }
            const {start, end} = props.defaultValue;
            return {
                start: start ? props.inTransformer(start) : null,
                end: end ? props.inTransformer(end) : null,
            };
        } else {
            return null;
        }
    }

    getMonthList(props) {
        const { initialDate, pastScrollRange, futureScrollRange, inTransformer } = props;
        const _initialDate = initialDate ? inTransformer(initialDate) : new Date();
        const minDate = addMonths(_initialDate, 0 - pastScrollRange);
        const maxDate = addMonths(_initialDate, futureScrollRange);
        const monthList = [];
        for (let i = minDate.getFullYear(); i <= maxDate.getFullYear(); i++) {
            let minMonth = 1, maxMonth = 12;
            if (i === minDate.getFullYear()) {
                minMonth = minDate.getMonth() + 1;
            }
            if (i === maxDate.getFullYear()) {
                maxMonth = maxDate.getMonth() + 1;
            }
            for (let j = minMonth - 1; j < maxMonth; j++) {
                monthList.push({
                    year: i,
                    month: j + 1,
                    shouldRender: false,
                });
            }
        }
        return monthList;
    }

    setDefaultTimeOfDate(date, rangeType) {
        date.setHours(rangeType !== 'end' ? 8 : 17);
        date.setMinutes(0);
        date.setSeconds(0);
        date.setMilliseconds(0);
        return date;
    }

    handleViewableItemsChanged({viewableItems}) {
        const monthList = this.state.monthList;
        const visibleMonths = [];
        const newMonthList = monthList.map((month, index) => {
            let shouldRender = false;
            for (let i = 0; i < viewableItems.length; i++) {
                const item = viewableItems[i];
                if (Math.abs(item.index - index) <= 1) {
                    shouldRender = true;
                }
            }
            if (shouldRender) {
                visibleMonths.push({ year: month.year, month: month.month });
            }
            if (month.shouldRender === shouldRender) {
                return month;
            }
            if (shouldRender) {
                return Object.assign({}, month, { shouldRender: true });
            } else {
                return Object.assign({}, month, { shouldRender: false });
            }
        });
        if (this.props.onVisibleMonthsChange) {
            this.props.onVisibleMonthsChange(visibleMonths);
        }
        this.setState({
            monthList: newMonthList
        });
    }

    handleSelect(date) {
        const { type, onSelect, outTransformer, time } = this.props;
        if (type === 'single') {
            if (time) {
                this.setState({
                    dateWithoutTime: this.setDefaultTimeOfDate(date),
                    timePickerVisible: true,
                });
                // 在时间选择完成后回调 onSelect
            } else {
                this.setState({
                    value: date,
                });
                onSelect && onSelect(getDateResult(date, outTransformer));
            }
        } else if (type === 'range') {
            this.setState(prevState => {
                let {start: prevStart, end: prevEnd} = prevState.value;
                let start = prevStart, end = prevEnd;
                if (prevStart === null) {
                    start = this.setDefaultTimeOfDate(date, 'start');
                }
                if (prevStart !== null && prevEnd === null) {
                    if (prevStart > date) {
                        end = this.setDefaultTimeOfDate(start, 'end');
                        start = this.setDefaultTimeOfDate(date, 'start');
                    } else {
                        end = this.setDefaultTimeOfDate(date, 'end');
                    }
                    if (!this.isDateOrDateRangeValid({ start, end })) {
                        // 如果选择的日期范围内存在不可选日期，则丢弃已选开始日期，将此次选择的日期作为开始日期
                        start = this.setDefaultTimeOfDate(date, 'start');
                        end = null;
                    }
                }
                if (prevStart !== null && prevEnd !== null) {
                    start = this.setDefaultTimeOfDate(date, 'start');
                    end = null;
                }
                onSelect && onSelect(getDateRangeResult(start, end, outTransformer));
                return {
                    value: { start, end },
                };
            });
        }
    }

    handleTimeSelect(date) {
        const { type, onSelect, outTransformer } = this.props;
        if (type === 'single') {
            this.setState(prevState => {
                const value = prevState.dateWithoutTime;
                value.setHours(date.getHours());
                value.setMinutes(date.getMinutes());
                return {
                    value,
                    timePickerVisible: false,
                };
            }, () => {
                onSelect && onSelect(getDateResult(this.state.value, outTransformer));
            });
        } else {
            this.setState(prevState => {
                const { start, end } = prevState.value;
                if (prevState.timePickerState === 'start') {
                    start.setHours(date.getHours());
                    start.setMinutes(date.getMinutes());
                } else if (prevState.timePickerState === 'end') {
                    end.setHours(date.getHours());
                    end.setMinutes(date.getMinutes());
                }
                return {
                    value: { start, end },
                    timePickerVisible: false,
                };
            }, () => {
                const { start, end } = this.state.value;
                onSelect && onSelect(getDateRangeResult(start, end, outTransformer));
            });
        }
    }

    handleCancelTimeSelect() {
        this.setState({
            timePickerVisible: false,
        });
    }

    handleShortcutSelect(shortcut) {
        const { type } = this.props;
        if (type === 'single') {
            this.handleSelect(shortcut.value);
            this.scrollToDate(shortcut.value);
        } else if (type === 'range') {
            this.setState({ value: { start: null, end: null } });
            this.handleSelect(shortcut.value.start);
            this.handleSelect(shortcut.value.end);
            this.scrollToDate(shortcut.value.start);
        }
    }

    scrollToDate(date) {
        const { year, month } = this.state.monthList[0];
        const selectedYear = date.getFullYear();
        const selectedMonth = date.getMonth() + 1;

        const monthDiff = selectedMonth - month;
        const yearDiff = selectedYear - year;
        const monthCount = yearDiff * 12 + monthDiff;
        this.flatList && this.flatList.scrollToOffset({
            offset: Math.max(0, monthCount * MONTH_HEIGHT - 20),
            animated: true,
        });
    }

    formatTime(date) {
        if (!(date instanceof Date)) {
            return '';
        }
        const hour = date.getHours();
        const minute = date.getMinutes();
        return `${hour >= 12 ? '下午' : '上午'} ${('0' + hour % 12).slice(-2)}:${('0' + minute).slice(-2)}`;
    }

    getMark(timestamp) {
        const markedDates = this.props.markedDates;
        const marks = markedDates.map(mark => {
            if (mark.type === 'single') {
                const date = getPureDay(mark.date);
                if (date.valueOf() === timestamp) {
                    return mark;
                }
            } else if (mark.type === 'range') {
                const start = mark.start ? getPureDay(mark.start).valueOf() : Number.MIN_VALUE;
                const end = mark.end ? getPureDay(mark.end).valueOf() : Number.MAX_VALUE;
                if (timestamp >= start && timestamp <= end) {
                    return mark;
                }
            }
        }).filter(mark => mark);
        return marks.length ? Object.assign.apply(Object, [{}].concat(marks)) : {};
    }

    isDateOrDateRangeValid(dateSpec) {
        const markedDates = this.props.markedDates;
        if (dateSpec instanceof Date) {
            const dateSpecTimestamp = getPureDay(dateSpec).valueOf();
            return !markedDates.some(mark => {
                if (mark.type === 'single') {
                    return mark.disabled && getPureDay(mark.date).valueOf() === dateSpecTimestamp;
                } else if (mark.type === 'range') {
                    const start = mark.start ? getPureDay(mark.start).valueOf() : Number.MIN_VALUE;
                    const end = mark.end ? getPureDay(mark.end).valueOf() : Number.MAX_VALUE;
                    return mark.disabled &&
                        dateSpecTimestamp >= start &&
                        dateSpecTimestamp <= end;
                }
            });
        } else {
            if (!dateSpec || !dateSpec.start instanceof Date  || !dateSpec.end instanceof Date) {
                return true;
            }
            const startSpecTimestamp = getPureDay(dateSpec.start).valueOf();
            const endSpecTimestamp = getPureDay(dateSpec.end).valueOf();
            return !markedDates.some(mark => {
                if (mark.type === 'single') {
                    const markDateTimestamp = getPureDay(mark.date).valueOf();
                    return mark.disabled &&
                        markDateTimestamp >= startSpecTimestamp &&
                        markDateTimestamp <= endSpecTimestamp;
                } else if (mark.type === 'range') {
                    const start = mark.start ? getPureDay(mark.start).valueOf() : Number.MIN_VALUE;
                    const end = mark.end ? getPureDay(mark.end).valueOf() : Number.MAX_VALUE;
                    return mark.disabled &&
                        endSpecTimestamp >= start &&
                        startSpecTimestamp <= end;
                }
            });
        }
    }

    getMark(timestamp) {
        const markedDates = this.props.markedDates;
        const marks = markedDates.map(mark => {
            if (mark.type === 'single') {
                const date = getPureDay(mark.date);
                if (date.valueOf() === timestamp) {
                    return mark;
                }
            } else if (mark.type === 'range') {
                const start = mark.start ? getPureDay(mark.start).valueOf() : Number.MIN_VALUE;
                const end = mark.end ? getPureDay(mark.end).valueOf() : Number.MAX_VALUE;
                if (timestamp >= start && timestamp <= end) {
                    return mark;
                }
            }
        }).filter(mark => mark);
        return marks.length ? Object.assign.apply(Object, [{}].concat(marks)) : {};
    }

    renderBoard() {
        const {type, time} = this.props;
        const {value} = this.state;
        if (type === 'single') {
            return (
                <View style={styles.board}>
                    {value ?
                        <View style={styles.flex1}>
                            <Text style={[
                                styles.dateContent,
                                time && styles.dateContentWithTime,
                            ]}>{format(value, 'YYYY/MM/DD')}</Text>
                            {time ? <View style={styles.timeWrapper}>
                                <Text style={styles.timeContent}>{this.formatTime(value)}</Text>
                            </View> : null}
                        </View> :
                        <Text style={styles.datePlaceholder}>{time ? '选择时间' : '选择日期'}</Text>}
                </View>
            );
        } else if (type === 'range') {
            const {start, end} = value;
            const dayCount = calculateDateRangeCount(start, end);
            return (
                <View style={styles.board}>
                    {start ?
                        <View style={styles.flex1}>
                            <Text style={[
                                styles.dateContent,
                                time && styles.dateContentWithTime,
                            ]}>{format(start, 'YYYY/MM/DD')}</Text>
                            {time ? <TouchableOpacity
                                style={styles.timeWrapper}
                                onPress={() => {
                                    this.setState({
                                        timePickerVisible: true,
                                        timePickerState: 'start',
                                    });
                                }}
                                hitSlop={{top: 4, right: 4, bottom: 4, left: 4}}
                            >
                                <Text style={styles.timeContent}>{this.formatTime(start)}</Text>
                                <Icon type="angleRight" size={12} color={theme('color_text_body')} />
                            </TouchableOpacity> : null}
                        </View> :
                        <Text style={styles.datePlaceholder}>{time ? '开始时间' : '开始日期'}</Text>}
                    {dayCount ? <View style={styles.dateSeparator}>
                        <View style={styles.dateSeparatorLine} />
                        <View style={styles.dateSeparatorLineAfter} />
                        <Text style={styles.dayCountText}>{dayCount}天</Text>
                    </View> : null}
                    {end ?
                        <View style={styles.flex1}>
                            <Text style={[
                                styles.endDateText,
                                styles.dateContent,
                                time && styles.dateContentWithTime,
                            ]}>{format(end, 'YYYY/MM/DD')}</Text>
                            {time ? <TouchableOpacity
                                style={[styles.endTimeWrapper, styles.timeWrapper]}
                                onPress={() => {
                                    this.setState({
                                        timePickerVisible: true,
                                        timePickerState: 'end',
                                    });
                                }}
                                hitSlop={{top: 4, right: 4, bottom: 4, left: 4}}
                            >
                                <Text style={[styles.endDateText, styles.timeContent]}>{this.formatTime(end)}</Text>
                                <Icon type="angleRight" size={12} color={theme('color_text_body')} />
                            </TouchableOpacity> : null}
                        </View> :
                        <Text style={[styles.endDateText, styles.datePlaceholder]}>{time ? '结束时间' : '结束日期'}</Text>}
                </View>
            );
        } else {
            return null;
        }
    }

    renderItem({item}) {
        if (item.shouldRender) {
            return (
                <MonthView
                    type={this.props.type}
                    value={this.state.value}
                    year={item.year}
                    month={item.month}
                    markedDates={this.props.markedDates}
                    getMark={this.getMark}
                    onSelect={this.handleSelect}
                />
            );
        } else {
            return (
                <View style={styles.monthPlaceholder} >
                    <Text style={styles.monthPlaceholderText}>{format(new Date(item.year, item.month - 1), 'YYYY年MM月')}</Text>
                </View>
            );
        }
    }

    renderShortcutBoard() {
        const { type, shortcuts } = this.props;
        const grid = shortcuts.reduce((acc, shortcut, index) => {
            const rowIndex = Math.floor(index / 3);
            if (acc[rowIndex]) {
                acc[rowIndex].push(shortcut);
            } else {
                acc[rowIndex] = [shortcut];
            }
            return acc;
        }, []);
        if (grid.length > 1) {
            let lastRow = grid[grid.length - 1];
            lastRow.push.apply(lastRow, new Array(3 - lastRow.length).fill(false));
        }

        return (
            grid.length ? <View style={[styles.shortcutBoard, { height: grid.length * 48 }]}>
                {grid.map((row, rowIndex) => {
                    return [
                        rowIndex === 0 && <View key={`${rowIndex}before`} style={styles.flex1} />,
                        (
                            <View key={rowIndex} style={styles.shortcutRow}>
                                {row.map((shortcut, index) => {
                                    let isInvalid = false;
                                    if (type === 'single') {
                                        isInvalid = !this.isDateOrDateRangeValid(shortcut.value);
                                    } else if (type === 'range') {
                                        isInvalid = !this.isDateOrDateRangeValid(shortcut.value);
                                    }
                                    return shortcut ? (
                                        <Text
                                            key={index}
                                            style={[
                                                styles.shortcutItem,
                                                styles.shortcutText,
                                                isInvalid && styles.disabledShortcutText,
                                            ]}
                                            onPress={!isInvalid ? () => this.handleShortcutSelect(shortcut) : null}
                                        >{shortcut.name}</Text>
                                    ) : <View key={index} style={styles.flex1} />;
                                })}
                            </View>
                        ),
                        <View key={`${rowIndex}after`} style={styles.flex1} />,
                    ];
                })}
            </View> : null
        );
    }

    renderTimePicker() {
        const { timePickerVisible, timePickerState, value, dateWithoutTime } = this.state;
        let title = `选择日期 ${format(dateWithoutTime, 'YYYY/MM/DD')}`;
        let minimumDate = null;
        let maximumDate = null;
        let defaultDate = dateWithoutTime;

        switch (timePickerState) {
            case 'start':
                title = `开始日期 ${format(value.start, 'YYYY/MM/DD')}`;
                maximumDate = value.end;
                defaultDate = value.start;
                break;
            case 'end':
                title = `结束日期 ${format(value.end, 'YYYY/MM/DD')}`;
                minimumDate = value.start;
                defaultDate = value.end;
                break;
        }
        return this.props.time ? <DatePicker
            visible={timePickerVisible}
            title={title}
            mode={'time'}
            minimumDate={minimumDate}
            maximumDate={maximumDate}
            minuteInterval={this.props.minuteInterval}
            defaultDate={defaultDate}
            onConfirmPress={this.handleTimeSelect}
            onCancelPress={this.handleCancelTimeSelect}
        /> : null;
    }

    render() {
        return (
            <View style={styles.container}>
                {this.renderBoard()}
                <MonthHeader/>
                <FlatList
                    ref={c => { this.flatList = c; }}
                    data={this.state.monthList}
                    automaticallyAdjustContentInsets={false}
                    removeClippedSubviews={false}
                    getItemLayout={(item, index) => {
                        return {length: MONTH_HEIGHT, offset: MONTH_HEIGHT * index, index};
                    }}
                    onViewableItemsChanged={this.handleViewableItemsChanged}
                    keyExtractor={item => `${item.year}-${item.month}`}
                    renderItem={this.renderItem}
                />
                {this.renderShortcutBoard()}
                {this.renderTimePicker()}
            </View>
        );
    }
}

Calendar.propTypes = {
    type: PropTypes.oneOf(['single', 'range']),
    initialDate: PropTypes.any,
    pastScrollRange: PropTypes.number,
    futureScrollRange: PropTypes.number,
    defaultValue: PropTypes.oneOfType([
        PropTypes.any,
        PropTypes.shape({
            start: PropTypes.any,
            end: PropTypes.any,
        })
    ]),
    shortcuts: PropTypes.arrayOf(
        PropTypes.shape({
            name: PropTypes.string,
            value: PropTypes.oneOfType([
                PropTypes.instanceOf(Date),
                PropTypes.shape({
                    start: PropTypes.instanceOf(Date),
                    end: PropTypes.instanceOf(Date),
                })
            ]),
        }),
    ),
    markedDates: PropTypes.arrayOf(
        PropTypes.shape({
            type: PropTypes.string.isRequired,
            date: PropTypes.instanceOf(Date),
            start: PropTypes.instanceOf(Date),
            end: PropTypes.instanceOf(Date),
            disabled: PropTypes.bool,
            badge: PropTypes.any,
            dot: PropTypes.bool,
        })
    ),
    time: PropTypes.bool,
    onSelect: PropTypes.func,
    inTransformer: PropTypes.func,
    outTransformer: PropTypes.func,
    onVisibleMonthsChange: PropTypes.func,
};

Calendar.defaultProps = {
    type: 'single',
    pastScrollRange: 50,
    futureScrollRange: 50,
    inTransformer: date => date,
    outTransformer: date => date,
    shortcuts: [],
    markedDates: [],
    time: false,
};

const styles = StyleSheet.create({
    container: {
        flex: 1,
        backgroundColor: theme('color_white'),
    },
    board: {
        height: 84,
        paddingHorizontal: 16,
        flexDirection: 'row',
        alignItems: 'center',
    },
    endDateText: {
        textAlign: 'right',
    },
    datePlaceholder: {
        flex: 1,
        color: theme('color_text_hint'),
        fontSize: FontSize.D2,
    },
    dateContent: {
        color: theme('color_text_title'),
        fontSize: Platform.OS === 'ios' ? FontSize.D1 : FontSize.D2,
        fontWeight: 'bold',
    },
    dateContentWithTime: {
        fontSize: FontSize.D2,
    },
    timeWrapper: {
        marginTop: 8,
        flexDirection: 'row',
        alignItems: 'center',
    },
    endTimeWrapper: {
        alignSelf: 'flex-end',
    },
    timeContent: {
        color: theme('color_text_body'),
        fontSize: FontSize.P2,
    },
    dateSeparator: {
        position: 'relative',
        width: 44,
        height: 44,
    },
    dateSeparatorLine: {
        position: 'absolute',
        right: 0,
        bottom: 0,
        borderBottomWidth: 44,
        borderBottomColor: theme('color_line_b'),
        borderLeftWidth: 44,
        borderLeftColor: 'transparent',
    },
    dateSeparatorLineAfter: {
        position: 'absolute',
        right: 0,
        bottom: 0,
        borderBottomWidth: 43,
        borderBottomColor: theme('color_white'),
        borderLeftWidth: 43,
        borderLeftColor: 'transparent',
    },
    dayCountText: {
        position: 'absolute',
        top: 12,
        width: 44,
        height: 20,
        backgroundColor: theme('color_white'),
        fontSize: FontSize.P1,
        color: theme('color_text_title'),
        textAlign: 'center',
        fontWeight: 'bold',
    },
    monthPlaceholder: {
        height: MONTH_HEIGHT,
        alignItems: 'center',
        justifyContent: 'center',
    },
    monthPlaceholderText: {
        color: theme('color_text_hint'),
        fontSize: FontSize.D1,
    },
    shortcutBoard: {
        borderTopWidth: StyleSheet.hairlineWidth,
        borderTopColor: theme('color_line_b'),
    },
    shortcutRow: {
        flexDirection: 'row'
    },
    shortcutItem: {
        flex: 1,
    },
    shortcutText: {
        textAlign: 'center',
        fontSize: FontSize.P1,
        color: theme('color_primary'),
    },
    disabledShortcutText: {
        color: `${theme('color_primary')}66`,
    },
    flex1: {
        flex: 1,
    }
});

export default Calendar;