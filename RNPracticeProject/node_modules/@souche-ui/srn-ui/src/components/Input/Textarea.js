import React from 'react';
import {
    TextInput,
    View,
    Text,
    Platform,
    StyleSheet,
    NativeModules,
} from 'react-native';
import PropTypes from 'prop-types';

import FontSize from '../../const/FontSize';
import theme from '../../theme';

const COUNTER_HEIGHT = 20;
const TEXT_HEIGHT = FontSize.P1 + 3;
// 通过判断版本号是否大于等于 0.50 来判断是否原生支持自适应高度
const rnVersion = NativeModules.PlatformConstants && NativeModules.PlatformConstants.reactNativeVersion;
const IS_NATIVE_AUTOEXPAND = rnVersion && rnVersion.major >= 0 && rnVersion.minor >= 50;

class Textarea extends React.Component {
    constructor(props) {
        super(props);
        const value = this.getValue(props) || '';
        let height = TEXT_HEIGHT * props.rows;

        this.state = {
            value,
            // 文本框高度
            height,
        };

        // value 的变化不会触发 onChange，也就无法动态改变高度
        // 通过 layouted 判断是否使用 onContentSizeChange 提供的高度值
        this.layouted = false;
        // 用来限制 onSubmitEditing 的重复触发
        this.isSubmit = false;
        // 保存当前文本选中状态
        this.selection = {
            start: 0,
            end: 0,
        };

        this.onChange = this.onChange.bind(this);
    }

    componentWillReceiveProps(nextProps) {
        if (typeof nextProps.value === 'string') {
            if (nextProps.value !== this.props.value) {
                this.layouted = false;
                this.setState({
                    value: nextProps.value,
                });
            }
        } else {
            if (nextProps.defaultValue !== this.props.defaultValue) {
                this.layouted = false;
                this.setState({
                    value: nextProps.defaultValue,
                });
            }
        }
    }

    getValue(props) {
        if (typeof props.value === 'string') {
            return props.value;
        } else {
            return props.defaultValue;
        }
    }

    calcHeight(inputHeight, autoHeight, inputCount, count, rows) {
        if (autoHeight) {
            return inputHeight;
        } else {
            return TEXT_HEIGHT * rows;
        }
    }

    /**
     * 判断输入框是否拥有焦点
     */
    isFocused() {
        return !!this.input && this.input.isFocused();
    }

    /**
     * 聚焦方法
     */
    focus() {
        this.input && this.input.focus();
    }

    /**
     * 失焦方法
     */
    blur() {
        this.input && this.input.blur();
    }

    onChange(event) {
        const text = event.nativeEvent.text;
        const { value, autoHeight, rows, count, onChange, onContentSizeChange } = this.props;
        const nextState = {};

        if (typeof value !== 'string') {
            // 如果不是可控的，则内部维护 value 状态
            nextState.value = text;
        }

        // 计算自动高度和固定高度情况下的实际高度
        // 另外，RN 0.46 开始就不支持在 onChange 方法里面使用 contentSize 了，要换成 onContentSizeChange
        // 然而 RN 0.43 Android 上 onContentSizeChange 只会被被调用一次
        if (event.nativeEvent.contentSize) {
            nextState.height = this.calcHeight(event.nativeEvent.contentSize.height, autoHeight, text.length, count, rows);
        }
        this.layouted = true;

        this.setState(nextState);

        onChange && onChange(text);
        onContentSizeChange && onContentSizeChange(event);
    }

    render() {
        const {
            placeholder,
            disabled,
            error,
            required,
            rows,
            count,
            autoHeight,
            style: styleProp,
            ...restProps,
        } = this.props;
        const inputCount = this.state.value.length;

        const containerStyle = {};
        // 如果原生支持自适应高度，则不需要 JS 端动态调整高度
        if (!IS_NATIVE_AUTOEXPAND || !autoHeight) {
            if (count && autoHeight && inputCount) {
                // 如果有计数器、自适应高度并且输入框有内容时，需要留出计数器高度的空间
                // 避免输入框和计数器显示在一行
                containerStyle.height = this.state.height + FontSize.P1 + 4;
            } else {
                containerStyle.height = this.state.height;
            }
        }

        return (
            <View style={styles.container}>
                <View style={containerStyle}>
                    <TextInput
                        style={[
                            styles.input,
                            styleProp,
                            [error && { color: theme('color_warning') },
                            disabled && { color: theme('color_text_caption') }],
                        ]}
                        placeholder={placeholder || (disabled ? '' : '请输入')}
                        underlineColorAndroid="transparent"
                        {...restProps}
                        ref={(c) => { this.input = c; }}
                        value={this.state.value}
                        editable={!disabled}
                        placeholderTextColor={disabled ? theme('color_text_caption') : required ? theme('color_primary') : theme('color_text_hint')}
                        multiline={true}
                        numberOfLines={rows}
                        blurOnSubmit={false}
                        onSubmitEditing={
                            (e) => {
                                if (Platform.OS === 'android') {
                                    // RN 0.43 在 Android 上不能实现回车换行
                                    // 以下为 hack
                                    // 方法大概就是在光标位置后插入换行符，然后调整光标位置
                                    // 如果设置了 maxLength 且当前内容长度（考虑选中了文字的情况）大于等于 maxLength，则不应用换行
                                    const text = this.state.value;
                                    const { start, end } = this.selection;
                                    if (!this.isSubmit &&
                                        (this.props.maxLength === undefined || text.length - (end - start) < this.props.maxLength)) {
                                        let newText = '';
                                        if (!this.selection) {
                                            newText = text + '\n';
                                        } else {
                                            const valueArr = text.split('');
                                            valueArr.splice(start, end - start, '\n');
                                            newText = valueArr.join('');
                                            // 调整光标位置
                                            if (start === end) {
                                                if (end < text.length) {
                                                    this.input.setNativeProps({
                                                        selection: {
                                                            start: start + 1,
                                                            end: end + 1,
                                                        }
                                                    });
                                                }
                                            } else {
                                                // 这句话是我写的，我也不是很懂为什么
                                                // 但是它确实可以工作
                                                this.input.setNativeProps({
                                                    selection: {
                                                        start: end,
                                                        end: end,
                                                    }
                                                });
                                            }
                                        }
                                        // 这里模拟触发 onChange 事件
                                        this.onChange({
                                            nativeEvent: {
                                                text: newText,
                                                contentSize: {
                                                    height: this.state.height + TEXT_HEIGHT
                                                }
                                            }
                                        });
                                    }
                                    this.isSubmit = !this.isSubmit;
                                }
                                this.props.onSubmitEditing && this.props.onSubmitEditing(e);
                            }
                        }
                        onSelectionChange={(e) => {
                            this.selection = e.nativeEvent.selection;
                            this.props.onSelectionChange && this.props.onSelectionChange(e);
                        }}
                        onChange={this.onChange}
                        onContentSizeChange={autoHeight ? ((e) => {
                            if (this.layouted) {
                                return;
                            }
                            this.setState({
                                height: this.calcHeight(e.nativeEvent.contentSize.height, autoHeight, inputCount, count, rows)
                            });
                        }) : null}

                    />
                </View>
                {/* 计数器 */}
                {count > 0 && <View style={[styles.counter, autoHeight && styles.floatCounter]}>
                    <Text style={styles.counterText}>
                        <Text style={{color: inputCount > count ? theme('color_warning') : theme('color_text_body')}}>{inputCount + ''}</Text>
                        /{count + ''}
                    </Text>
                </View>}
            </View>
        );
    }
}

Textarea.propTypes = {
    value: PropTypes.string,
    defaultValue: PropTypes.string,
    placeholder: PropTypes.string,
    disabled: PropTypes.bool,
    required: PropTypes.bool,
    error: PropTypes.bool,
    rows: PropTypes.number,
    count: PropTypes.number,
    autoHeight: PropTypes.bool,
    onChange: PropTypes.func,
    onPress: PropTypes.func
};

Textarea.defaultProps = {
    disabled: false,
    required: false,
    error: false,
    rows: 1,
    count: 0,
    autoHeight: false
};

const styles = StyleSheet.create({
    container: {
        position: 'relative',
    },
    input: {
        padding: 0,
        flex: 1,
        textAlignVertical: 'top',
        fontSize: FontSize.P1,
        color: theme('color_text_title'),
        ...Platform.select({
            ios: {
                marginTop: -(1 + StyleSheet.hairlineWidth),
            },
        }),
    },
    floatCounter: {
        position: 'absolute',
        right: 0,
        bottom: 0,
    },
    counter: {
        height: COUNTER_HEIGHT,
        backgroundColor: 'transparent',
    },
    counterText: {
        textAlign: 'right',
        fontSize: FontSize.P1,
        lineHeight: FontSize.P1 + 4,
        color: theme('color_text_body'),
    },
});

export default Textarea;
