import React from 'react';

import {
    StyleSheet,
    View,
    Text,
    ListView,
    Animated,
    Platform,
    Dimensions,
    TouchableOpacity,
} from 'react-native';
import PropTypes from 'prop-types';

import FontSize from '../../const/FontSize';
import theme from '../../theme';

// import QuickNavigation from './QuickNavigation';

const SCREEN_WIDTH = Dimensions.get('window').width;

class CascadeModel extends React.Component {

    constructor(props) {
        super(props);

        this.show = this.show.bind(this);
        this.hide = this.hide.bind(this);
        this.renderHeader = this.renderHeader.bind(this);
        this.renderSectionHeader = this.renderSectionHeader.bind(this);
        this.renderRow = this.renderRow.bind(this);
    }

    state = {
        animatedValue: new Animated.Value(0),
        dataSource: null,
    }

    section = []
    sectionPosition = []

    setSectionPosition(data) {
        if (data.length === 0) {
            return;
        }
        let positionCache = 0;
        this.sectionPosition.push(0);
        data.forEach((v, i) => {
            positionCache += this.props.sectionHeight + v.rows.length * this.props.rowHeight;
            this.section.push(v.section && v.section[0]);
            this.sectionPosition.push(positionCache);
        });
    }

    dataSource = new ListView.DataSource({
        getRowData: (dataBlob, sectionID, rowID) => dataBlob[rowID],
        getSectionHeaderData: (dataBlob, sectionID) => dataBlob[sectionID],
        rowHasChanged: (row1, row2) => row1 !== row2,
        sectionHeaderHasChanged: (s1, s2) => s1 !== s2
    })

    componentWillMount() {
        this.section = [];
        this.sectionPosition = [];
        const obj = this.buildDataSource(this.props.data);
        this.setState({
            dataSource: this.dataSource.cloneWithRowsAndSections(obj.dataBlob, obj.sectionIDs, obj.rowIDs)
        });
        this.props.spitOutClearFunc(this.clearDataSource);
        this.props.spitOutHideFunc(this.hide);

        this.props.quickNavigation && this.setSectionPosition(this.props.data);
    }

    componentWillReceiveProps(nextProps) {
        this.section = [];
        this.sectionPosition = [];
        const obj = this.buildDataSource(nextProps.data);
        if (this.props.data !== nextProps.data) {
            this.listView.scrollTo({x: 0, y: 0, animated: false});
        }
        this.setState({
            dataSource: this.dataSource.cloneWithRowsAndSections(obj.dataBlob, obj.sectionIDs, obj.rowIDs)
        });

        this.props.quickNavigation && this.setSectionPosition(nextProps.data);
    }

    buildDataSource(data) {
        let dataBlob = {}, sectionIDs = [], rowIDs = [];
        data.forEach(function(v, i) {
            dataBlob[i] = v.section;
            sectionIDs.push(i);
            rowIDs[i] = [];
            v.rows.forEach((_v, _i) => {
                if (_i === 0 && _v.first_row === undefined) {
                    _v.first_row = true;
                }
                if (_i === v.rows.length - 1 && _v.last_row === undefined) {
                    _v.last_row = true;
                }
                dataBlob['row' + v.section + _i] = _v;
                rowIDs[i].push('row' + v.section + _i);
            });
        });

        return {dataBlob, sectionIDs, rowIDs};
    }

    clearDataSource() {
        this.setState({
            dataSource: this.dataSource.cloneWithRowsAndSections({}, [], [])
        });
    }

    value = 0

    show(endFn) {
        /*Animated.timing(
            this.state.animatedValue,
            {
                toValue: 1,
                duration: 200
            }
        ).start(endFn);*/
        if (this.value === 0) {
            this.value = 1;
            Animated.timing(
                this.state.animatedValue,
                {
                    toValue: this.value,
                    duration: 200,
                    // useNativeDriver: true,
                }
            ).start(endFn);
        } else if (this.value === 1) {
            endFn && endFn();
        }
    }

    hide(endFn) {
        this.value = 0;
        Animated.timing(
            this.state.animatedValue,
            {
                toValue: 0,
                duration: 200,
                // useNativeDriver: true,
            }
        ).start(endFn);

        /*if (this.value === 1) {
            this.value = 0;
            Animated.timing(
                this.state.animatedValue,
                {
                    toValue: this.value,
                    duration: 200
                }
            ).start(endFn);
        } else if (this.value === 0) {
            endFn && endFn();
        }*/
    }

    navChange(index) {
        this.listView.scrollTo({x: 0, y: this.sectionPosition[index], animated: false});
    }

    renderHeader() {
        return this.props.renderHeader ? this.props.renderHeader() : null;
    }

    renderSectionHeader(sectionData, sectionID) {
        return this.props.renderSection(sectionData, sectionID, this.show, this.hide);
    }

    renderRow(rowData, sectionID, rowID) {
        return this.props.renderRow(rowData, sectionID, rowID, this.show, this.hide);
    }

    render() {
        return (
            <View style={styles.container}>
                <View style={styles.content}>
                    {this.props.level !== 1 && (<View style={styles.navigator}>
                        <TouchableOpacity style={styles.back} onPress={this.props.onBack}>
                            <Text style={styles.backText}>返回</Text>
                        </TouchableOpacity>
                        <Text style={styles.navigatorText} numberOfLines={1} ellipsizeMode="middle">{this.props.title}</Text>
                    </View>)}
                    <ListView
                        ref={c => { this.listView = c; }}
                        renderHeader={this.renderHeader}
                        initialListSize={this.props.data.length}
                        pageSize={this.props.data.length}
                        dataSource={this.state.dataSource}
                        renderSectionHeader={this.renderSectionHeader}
                        renderRow={this.renderRow}
                        onScrollBeginDrag={() => this.props.onScrollBegin(this.hide)}
                        automaticallyAdjustContentInsets={false}
                        showsVerticalScrollIndicator={false}
                        removeClippedSubviews={false}
                    />
                </View>
                {/* {this.props.quickNavigation === true && this.props.data.length > 0 && <QuickNavigation items={this.section} navChange={this.navChange} navTextStyle={this.props.navTextStyle} />} */}
                <Animated.View
                    style={[styles.children, {
                        width: SCREEN_WIDTH - this.props.gap,
                        transform: [{
                            translateX: this.state.animatedValue.interpolate({
                                inputRange: [0, 1],
                                outputRange: [SCREEN_WIDTH + 20, this.props.level === 1 ? this.props.gap : 0]
                            })
                        }]
                    }]}
                >
                    {this.props.children}
                </Animated.View>
            </View>
        );
    }

}

const styles = StyleSheet.create({
    container: {
        flex: 1,
        position: 'relative',
        backgroundColor: theme('color_white'),
    },
    content: {
        position: 'absolute',
        top: 0,
        left: 0,
        bottom: 0,
        right: 0,
    },
    children: {
        position: 'absolute',
        top: 0,
        left: 0,
        bottom: 0,
        backgroundColor: theme('color_press'),
        borderLeftColor: theme('color_text_hint'),
        borderLeftWidth: Platform.OS === 'android' ? StyleSheet.hairlineWidth : 0,
        shadowColor: 'rgb(0,0,0)',
        shadowOffset: {
            width: 8,
            height: 0
        },
        shadowOpacity: 0.4,
        shadowRadius: 16
    },
    navigator: {
        position: 'relative',
        height: 48,
        paddingHorizontal: 64,
        alignItems: 'center',
        justifyContent: 'center',
    },
    navigatorText: {
        color: theme('color_text_title'),
        fontSize: FontSize.P1,
        fontWeight: '500',
    },
    back: {
        position: 'absolute',
        left: 16,
    },
    backText: {
        color: theme('color_text_title'),
        fontSize: FontSize.P1,
    },
});

CascadeModel.propTypes = {
    gap: PropTypes.number,
    data: PropTypes.array.isRequired,
    renderSection: PropTypes.func.isRequired,
    renderRow: PropTypes.func.isRequired,
    onScrollBegin: PropTypes.func,
    onBack: PropTypes.func,
    spitOutClearFunc: PropTypes.func,
    spitOutHideFunc: PropTypes.func,
    level: PropTypes.number,
    quickNavigation: PropTypes.bool,
    sectionHeight: PropTypes.number,
    rowHeight: PropTypes.number,
};

CascadeModel.defaultProps = {
    gap: SCREEN_WIDTH * 0.17,
    level: 1,
    quickNavigation: false,
    sectionHeight: 28,
    rowHeight: 44,
    onScrollBegin: fn => fn(),
    onBack: function() {},
    spitOutClearFunc: function() {},
    spitOutHideFunc: function() {},
};

export default CascadeModel;
