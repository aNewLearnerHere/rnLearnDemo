import React from 'react';
import {
    View,
    TouchableWithoutFeedback,
    TouchableOpacity,
    Text,
    Animated,
} from 'react-native';

import PropTypes from 'prop-types';
import FontSize from '../../const/FontSize';
import theme from '../../theme';
import styleUtil from '../../util/styleUtil';
import Icon from '../Icon';

class NoticeBar extends React.Component {
    constructor(props) {
        super(props);

        this.state = {
            // 只有当通知栏是自动关闭的，才会有一个显示的动画，hidden 初始值也就为 true
            hidden: this.props.duration !== 0,
            fadeAnim: new Animated.Value(this.props.duration === 0 ? 1 : 0),
        };

        this.handleHide = this.handleHide.bind(this);
    }

    hideTimmer = null;

    componentWillReceiveProps(nextProps) {
        if (nextProps.duration !== 0 && nextProps.visible !== this.props.visible) {
            if (nextProps.visible && this.state.hidden) {
                // 如果通知栏是自动关闭的且
                // 如果 visible 变为 true 且通知栏为隐藏状态，则开始一系列动画
                this.begin(nextProps);
            }
        }
    }

    componentDidMount() {
        const { duration, visible } = this.props;

        if (duration !== 0 && visible) {
            this.begin(this.props);
        }
    }

    componentWillUnmount() {
        clearTimeout(this.hideTimmer);
    }

    begin(props) {
        // 一系列变化过程，显示动画 -> 保持显示 duration 这么长时间 -> 隐藏动画
        const { duration, onVisibleChange } = props;
        this.hideTimmer = setTimeout(() => {
            // 隐藏动画
            this.startHideAnimation(() => {
                // 隐藏动画完成后需要通知组件调用者
                onVisibleChange && onVisibleChange(false);
            });
        }, duration);

        // 显示动画
        this.startShowAnimation();
    }

    startShowAnimation(onEnd) {
        // 先让挂载元素，再开始动画
        this.setState({ hidden: false }, () => {
            Animated.timing(
                this.state.fadeAnim,
                { toValue: 1 },
            ).start(e => {
                onEnd && onEnd();
            });
        });
    }

    startHideAnimation(onEnd) {
        // 先开始动画，动画结束后卸载元素
        Animated.timing(
            this.state.fadeAnim,
            { toValue: 0 },
        ).start(e => {
            this.setState({ hidden: true });
            onEnd && onEnd();
        });
    }

    handleHide() {
        // 如果有的话，就关闭“自动关闭动画”的定时器
        clearTimeout(this.hideTimmer);
        this.startHideAnimation(() => {
            if (this.props.duration !== 0) {
                this.props.onVisibleChange && this.props.onVisibleChange(false);
            }
        });
    }

    render() {
        const {
            children,
            closable,
            action,
            float,
            onPress,
        } =  this.props;

        const contentColor = this.props.textStyle && this.props.textStyle.color || theme('color_text_caption');

        return (
            <TouchableWithoutFeedback onPress={onPress}>
                {!this.state.hidden ? <Animated.View style={[styles.container, this.props.style, float && styles.float, { opacity: this.state.fadeAnim }]}>
                    <Text style={[styles.text, this.props.textStyle]}>{children}</Text>
                    {action ? React.cloneElement(action, [{ style: styles.span }].concat(action.props.style)) : null}
                    {
                        closable ?
                            <TouchableOpacity onPress={this.handleHide}>
                                <Icon style={styles.span} color={contentColor} type={Icon.close} />
                            </TouchableOpacity> :
                            null
                    }
                    {onPress ? <Icon style={styles.span} color={contentColor} type={Icon.angleRight} /> : null}
                </Animated.View> : <View/>}
            </TouchableWithoutFeedback>
        );
    }
}

NoticeBar.propTypes = {
    closable: PropTypes.bool,
    action: PropTypes.element,
    float: PropTypes.bool,
    duration: PropTypes.number,
    visible: PropTypes.bool,
    onPress: PropTypes.func,
    onClose: PropTypes.func,
    onVisibleChange: PropTypes.func,
    style: View.propTypes.style,
    textStyle: Text.propTypes.style,
};

NoticeBar.defaultProps = {
    closable: false,
    float: false,
    duration: 0,
    visible: true,
};

const styles = styleUtil.create({
    common: {
        container: {
            backgroundColor: theme('color_background_notice'),
            paddingHorizontal: 16,
            flexDirection: 'row',
            alignItems: 'center',
        },
        text: {
            color: theme('color_text_title'),
            fontSize: FontSize.P2,
            marginVertical: 12,
            lineHeight: FontSize.P2 + 6,
            flex: 1,
        },
        span: {
            marginLeft: 16,
        },
        float: {
            position: 'absolute',
            top: 0,
            zIndex: 1,
        },
    }
});

export default NoticeBar;