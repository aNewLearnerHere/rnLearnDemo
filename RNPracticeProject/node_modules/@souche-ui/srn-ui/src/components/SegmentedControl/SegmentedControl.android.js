import React from 'react';
import {
    View,
    Text,
    TouchableHighlight,
    Animated,
    StyleSheet,
} from 'react-native';
import PropTypes from 'prop-types';
import normalizeColor from 'react-native/Libraries/StyleSheet/normalizeColor';
import { setNormalizedColorAlpha, colorPipe } from '../../util/colorUtil';
import FontSize from '../../const/FontSize';
import theme from '../../theme';

export default class SegmentedControl extends React.Component{
    static defaultProps = {
        selectedIndex:0,
        tintColor: theme('color_primary'),
        value:[],
    }
    static PropTypes = {
        disabled: PropTypes.bool,
        values: PropTypes.array,
        tintColor: PropTypes.string,
        selectedIndex: PropTypes.number,
        onChange: PropTypes.func,
        onValueChange: PropTypes.func,
        style: View.propTypes.style,
    };

    constructor(props) {
        super(props);
        this.customizeColor(props);
        this.segmentedControl = [];
        this.pressedIndex = -1;
        this.state = {
            selectedIndex: props.selectedIndex,
            animateColor: props.values.map((text,index) => {
                if (index === props.selectedIndex) {
                    return new Animated.Value(1);
                } else {
                    return new Animated.Value(0);
                }
            }),
        };

    }
    customizeColor = (props) => {
        const {disabled,tintColor} = props;
        this.mainColor = disabled ? colorPipe(tintColor,0.75,'#fff') : tintColor;
        this.textColor = disabled ? colorPipe(tintColor,0.3,'#fff') : tintColor;
        this.selectedColor = disabled ? colorPipe('#fff',0.3,this.mainColor) : '#fff';
        this.touchColor = disabled ? null : setNormalizedColorAlpha(normalizeColor(tintColor), 0.1);
    }

    componentWillReceiveProps(nextProps) {
        if (nextProps.values !== this.props.values) {
            this.segmentedControl = [];
            this.setState({
                animateColor: nextProps.values.map((text,index) => {
                    if (index === nextProps.selectedIndex) {
                        return new Animated.Value(1);
                    } else {
                        return new Animated.Value(0);
                    }
                }),
            });
        }
        if (nextProps.selectedIndex !== this.props.selectedIndex) {
            this.setState({
                selectedIndex: nextProps.selectedIndex,
            });
            this.props.values.map((t,i) => {
                if (i === nextProps.selectedIndex) {
                    this.state.animateColor[i].setValue(1);
                } else {
                    this.state.animateColor[i].setValue(0);
                }
            });
        }
        if (nextProps.disabled !== this.props.disabled || nextProps.tintColor !== this.props.tintColor) {
            this.customizeColor(nextProps);
        }
    }

    _onChange = (e,value,index) => {
        const { disabled, onChange, onValueChange } = this.props;
        if (!disabled){
            e.nativeEvent.selectedSegmentIndex = index;
            e.nativeEvent.value = value;
            this.setState({selectedIndex:index});
            if (onChange){
                onChange(e);
            }
            if (onValueChange){
                onValueChange(value);
            }
        }
        Animated.parallel(
            this.props.values.map((t,i) => {
                if (i === index) {
                    return Animated.timing(
                        this.state.animateColor[i],
                        {
                            toValue:1,
                            duration:150,
                        }
                    );
                } else {
                    return Animated.timing(
                        this.state.animateColor[i],
                        {
                            toValue:0,
                            duration:150,
                        }
                    );
                }
            })
        ).start();
    }
    //直接操作dom
    _onPressIn = (index,touchColor) => {
        this.pressedIndex = index;
        this.segmentedControl[index] && this.segmentedControl[index].setNativeProps({
            style: {
                backgroundColor: touchColor
            }
        });
    }
    _onPressOut = (index) => {
        this.pressedIndex = -1;
        this.segmentedControl[index] && this.segmentedControl[index].setNativeProps({
            style: {
                backgroundColor: 'rgba(255,255,255,0)'
            }
        });
    }
    _renderTab = (disabled) => {
        if (!disabled){
            return;
        }
    }
    /**
     * 旧版本<Text>传入数字会有一定几率报错 +toString()
     * RN动画outputRange不支持数字 直接使用tintColor
     */

    render() {
        const {values, style, tintColor, disabled} = this.props;
        const {selectedIndex} = this.state;
        const {mainColor, textColor, selectedColor, touchColor} = this;
        const renderTab = () => {
            if (!disabled){
                return values.map((text,index) =>{
                    const el =  <Animated.View  style={[
                                                    index === values.length - 1 ? styles.lastTab : styles.basicTab,
                                                    !index && styles.firstTab,
                                                    {backgroundColor:this.state.animateColor[index].interpolate({
                                                        inputRange: [0,1],
                                                        outputRange: ['rgba(255,255,255,0)', tintColor]
                                                    })}
                                                ]}
                                                key={index}
                                                ref={(item) => {this.segmentedControl[index] = item;}}>

                                    <TouchableHighlight
                                        underlayColor="transparent"
                                        style={styles.touch}
                                        onPress={(e) => this._onChange(e,text,index)}
                                        onPressIn={() => {this._onPressIn(index,touchColor);}}
                                        onPressOut={() => {this._onPressOut(index);}}
                                    >
                                        <Text style={[styles.textStyle, index === selectedIndex ? {color:selectedColor} : {color:textColor}]}>
                                            {text.toString()}
                                        </Text>
                                    </TouchableHighlight>
                                </Animated.View>;
                    if (index === 0) {
                        return el;
                    } else {
                        return [<View style={[styles.divider, {backgroundColor: mainColor}]}/>, el];
                    }
                });
            } else {
                return values.map((text,index) =>{
                    const el =  <View   style={[
                                            index === values.length - 1 ? styles.lastTab : styles.basicTab,
                                            !index && styles.firstTab,
                                            index === selectedIndex && {backgroundColor:mainColor}
                                        ]}
                                        key={index}
                                >
                                    <Text style={[styles.textStyle, index === selectedIndex ? {color:selectedColor} : {color:textColor}]}>
                                        {text.toString()}
                                    </Text>
                                </View>;
                    if (index === 0) {
                        return el;
                    } else {
                        return [<View style={[styles.divider, {backgroundColor: mainColor}]}/>, el];
                    }
                });
            }
        };
        return (
            <View>
               <View style={[styles.contain,{borderColor:mainColor},style]}>
                    {renderTab()}
                </View>
            </View>
        );
    }
}
//添加borderRadius会导致border消失 用负margin补充
const styles = StyleSheet.create({
    contain:{
        alignSelf:'stretch',
        height:28,
        flexDirection:'row',
        borderWidth:1,
        borderRadius:4,
        overflow:'hidden',
    },
    touch:{
        flex:1,
    },
    basicTab:{
        flex:1,
        marginVertical: -1,
    },
    lastTab:{
        flex:1,
        marginVertical: -1,
        marginRight:-1,
        borderTopRightRadius:4,
        borderBottomRightRadius:4,
    },
    firstTab:{
        marginLeft:-1,
        borderTopLeftRadius:4,
        borderBottomLeftRadius:4,
    },
    divider: {
        width: 1,
    },
    textStyle:{
        flex:1,
        fontSize: FontSize.P2,
        textAlignVertical:'center',
        textAlign:'center',
        backgroundColor:'transparent'
    },
});


