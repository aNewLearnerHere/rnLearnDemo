import React from 'react';
import {
    View,
    Modal,
    TouchableOpacity,
    Dimensions,
    InteractionManager,
    UIManager,
    StyleSheet,
} from 'react-native';

import PropTypes from 'prop-types';

import PopoverMenu from './PopoverMenu';
import srnTheme from '../../theme';

class Popover extends React.PureComponent {
    static Menu = PopoverMenu

    constructor(props) {
        super(props);

        this.state = {
            visible: typeof props.visible === 'undefined' ? props.defaultVisible : props.visible,
            top: 0,
            right: 0,
            left: 0,
            width: 0,
        };

        this.onLayout = this.onLayout.bind(this);
        this.processContent = this.processContent.bind(this);
    }

    componentWillReceiveProps(nextProps) {
        if (nextProps.visible !== this.props.visible && typeof nextProps.visible !== 'undefined') {
            this.setState({ visible: nextProps.visible });
        }
    }

    toggle(visible) {
        const { width } = Dimensions.get('window');
        if (visible) {
            this.container.measureInWindow((x, y, w, h) => {
                this.setState({
                    top: h + y,
                    right: width - x - w / 2,
                    left: x + w / 2,
                });
            });
        }
        if (typeof this.props.visible === 'undefined') {
            // 如果 visible 是不可控的，则内部维护状态
            this.setState({ visible });
        }
        this.props.onVisibleChange && this.props.onVisibleChange(visible);
    }

    onLayout(e) {
        const { width } = Dimensions.get('window');
        const target = e.target;

        InteractionManager.runAfterInteractions(() => {
            // 不加这一句测量出来的位置和尺寸都是 0
            requestAnimationFrame(() => {
                // 测量目标元素的位置和尺寸，用于计算 popover 的位置
                UIManager.measureInWindow(target, (x, y, w, h) => {
                    this.setState({
                        top: h + y,
                        right: width - x - w / 2,
                        left: x + w / 2,
                    });
                });
            });
        });
    }

    processContent(content) {
        // 当 Popover 用在导航栏上时，不能维护状态，所以只能使用非可控模式
        // 需要以下的看起来耦合度非常高的代码，来实现点击菜单后关闭 Popover 的功能
        // 在导航栏支持自定义组件维护状态后，就可以去掉这段代码
        if (typeof this.props.visible === 'undefined' && content.props.children) {
            return React.cloneElement(content, {
                theme: this.props.theme,
                children: React.Children.map(content.props.children, (child, i) => {
                    if (child.type === PopoverMenu.Item) {
                        return React.cloneElement(child, {
                            key: i,
                            onPress: (e) => {
                                this.setState({ visible: false });
                                if (child.props && typeof child.props.onPress === 'function') {
                                    child.props.onPress(e);
                                }
                            }
                        });
                    } else {
                        return child;
                    }
                })
            });
        } else {
            return React.cloneElement(content, {
                theme: this.props.theme,
            });
        }
    }

    render() {
        const {
            content,
            placement,
            offset,
            style: styleProp,
            popStyle,
            theme: themeProp,
            children,
        } =  this.props;

        const offsetTop = offset.top || 0;

        // 默认为 placement 为 bottomRight，动态样式如下
        let popoverStyle = {
            alignItems: 'flex-end',
            top: this.state.top + offsetTop,
            right: this.state.right - 12 - 6,
        };
        let arrowStyle = { marginRight: 12 };

        if (placement === 'bottomLeft') {
            // 当 placement 为 bottomLeft 时，调整为左对齐
            popoverStyle = {
                alignItems: 'flex-start',
                top: this.state.top + offsetTop,
                left: this.state.left - 12 - 6,
            };
            arrowStyle = { marginLeft: 12 };
        } else if (placement === 'bottom') {
            // 当 placement 为 bottom 时，调整为中间对齐
            popoverStyle = {
                alignItems: 'center',
                top: this.state.top + offsetTop,
                // 为避免闪烁，在没计算出 popover 时保持 popover 在可视区外
                left: this.state.width ? this.state.left - this.state.width / 2 : 9999,
            };
            arrowStyle = false;
        }

        return (
            <TouchableOpacity
                ref={(c) => { this.container = c; }}
                style={styleProp}
                hitSlop={{top: 4, right: 4, bottom: 4, left: 4}}
                onPress={() => this.toggle(!this.state.visible) }
                onLayout={this.onLayout}
            >
                <Modal
                    transparent={true}
                    // 后面两个判断也是避免闪烁
                    visible={this.state.visible && this.state.top !== 0 && this.state.right !== 0}
                    onRequestClose={() => {
                        this.setState({ visible: false });
                        this.props.onVisibleChange && this.props.onVisibleChange(false);
                    }}
                >
                    {/* popover 的背景，点击后关闭 popover */}
                    <TouchableOpacity activeOpacity={1} style={styles.backdrop} onPress={() => this.toggle(false)}>
                        <View style={[styles.container, themeProp === 'light' && styles.lightContainer, popoverStyle]}>
                            {/* 气泡的小尖尖 */}
                            <View style={[styles.triangle, themeProp === 'light' && styles.lightTriangle, arrowStyle]} />
                            {/* 一个没有绑定 press 事件的 Touchable* 可以阻止事件冒泡 */}
                            <TouchableOpacity
                                activeOpacity={1}
                                onLayout={e => this.setState({ width: e.nativeEvent.layout.width })}
                                style={[styles.popover, themeProp === 'light' && styles.lightPopover, popStyle]}
                            >
                                {this.processContent(content)}
                            </TouchableOpacity>
                        </View>
                    </TouchableOpacity>
                </Modal>
                {children}
            </TouchableOpacity>
        );
    }
}

Popover.propTypes = {
    theme: PropTypes.string,
    content: PropTypes.element,
    placement: PropTypes.string,
    offset: PropTypes.shape({
        top: PropTypes.number
    }),
    defaultVisible: PropTypes.bool,
    visible: PropTypes.bool,
    onVisibleChange: PropTypes.func,
    style: View.propTypes.style,
    popStyle: View.propTypes.style,
};

Popover.defaultProps = {
    theme: 'dark',
    placement: 'bottomRight',
    offset: {
        top: 14
    },
    defaultVisible: false,
};

const styles = StyleSheet.create({
    backdrop: {
        flex: 1,
    },
    container: {
        position: 'absolute',
    },
    lightContainer: {
        shadowColor: '#000000',
        shadowOffset: { height: 1 },
        shadowOpacity: 0.3,
        shadowRadius: 6,
        elevation: 20,
        // elevation 必须在设置了不完全透明的 backgroundColor 的情况下，才能产生阴影效果
        // 这里使用一个接近完全透明的背景色达到目的
        backgroundColor: 'rgba(0, 0, 0, 0.01)',
    },
    popover: {
        minWidth: 130,
    },
    lightPopover: {
        minWidth: 136,
    },
    triangle: {
        height: 0,
        width: 0,
        backgroundColor: 'transparent',
        borderStyle: 'solid',
        borderLeftWidth: 6,
        borderRightWidth: 6,
        borderBottomWidth: 6,
        borderLeftColor: 'transparent',
        borderRightColor: 'transparent',
        borderBottomColor: srnTheme('color_mask'),
    },
    lightTriangle: {
        borderBottomColor: srnTheme('color_white'),
    },
});

export default Popover;
